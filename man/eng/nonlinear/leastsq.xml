<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "../../man.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>leastsq  </TITLE>
  <TYPE>Scilab Function  </TYPE>
  <DATE>April 1999  </DATE>
  <SHORT_DESCRIPTION name="leastsq"> Solves non-linear least squares problems  </SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>[f,xopt]=leastsq([imp,] fun [,Dfun],x0)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[f,[xopt,[gradopt]]]=leastsq(fun [,Dfun],[contr],x0,[&apos;algo&apos;],[df0,[mem]],  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>     ,[stop],[&apos;in&apos;])  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>imp  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : scalar argument used to set the trace mode. <VERB>imp=0</VERB> nothing (execpt errors) is reported, <VERB>imp=1</VERB> initial and final reports, <VERB>imp=2</VERB> adds a report per iteration, <VERB>imp&gt;2</VERB> add reports on linear search. Warning, most of these reports are written on the Scilab standard output. 
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>fun  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : external, i.e Scilab function or string (<VERB>fun</VERB> is the function defining the least square probleme: see below.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>x0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : real vector (initial value of variable to be minimized).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>f  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : value of optimal least square value.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>xopt  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : best value of <VERB>x</VERB> found.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>contr  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : <VERB>&apos;b&apos;,binf,bsup</VERB>  with <VERB>binf</VERB> and <VERB>bsup</VERB> real vectors with same dimension as <VERB>x0</VERB>. <VERB>binf</VERB> and <VERB>bsup</VERB> are lower and upper bounds on <VERB>x</VERB>.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>algo  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : A string with possible values :<VERB>&apos;qn&apos;</VERB> or <VERB>&apos;gc&apos;</VERB> or <VERB>&apos;nd&apos;</VERB> . This string stands for quasi-Newton (default),  conjugate gradient or non-differentiable respectively.  Note that <VERB>&apos;nd&apos;</VERB> does not accept bounds on <VERB>x</VERB> ).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>df0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : real scalar. Guessed decreasing of <VERB>f</VERB> at first iteration. (<VERB>df0=1</VERB> is the default value).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>mem :  </PARAM_NAME>
  <PARAM_DESCRIPTION>
     integer, number of variables used to approximate the  Hessian, (<VERB>algo=&apos;gc&apos; or &apos;nd&apos;</VERB>). Default value is around 6.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>stop  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    :  sequence of optional parameters controlling the  convergence of the algorithm. <VERB>  stop=  &apos;ar&apos;,nap, [iter [,epsg [,epsf [,epsx]]]]</VERB>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>&quot;ar&quot;  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : reserved keyword for stopping rule selection defined as follows:
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>nap  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : maximum number of calls to <VERB>fun</VERB> allowed.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>iter  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : maximum number of iterations allowed.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>epsg  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : threshold on gradient norm.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>epsf  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : threshold controlling decreasing of <VERB>f</VERB>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>epsx  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : threshold controlling variation of <VERB>x</VERB>. This vector (possibly matrix) of same size as <VERB>x0</VERB> can be used to scale <VERB>x</VERB>.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>&quot;in&quot;  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : reserved  keyword for initialization of parameters used when <VERB>fun</VERB> in given as a Fortran routine (see below).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>gradopt  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    :  gradient of <VERB>fun</VERB> at <VERB>xopt</VERB>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
  <P>
    Non-linear optimization routine for programs without constraints or with bound constraints: 
  </P>
  <VERBATIM><![CDATA[
min sum(f(x).^2  w.r.t x.
   ]]></VERBATIM>
 

  <DESCRIPTION_ITEM  label='fun'> 
    is an &quot;external&quot; i.e function, or list or C or Fortran routine (see &quot;external&quot;). This external must return a vector <VERB>f</VERB> such  as (<VERB>f(j)=fj(x)</VERB>) for a given <VERB>x</VERB>. 
  </DESCRIPTION_ITEM>
  <P>
    If <VERB>fun</VERB> is a function, the calling sequence for <VERB>fun</VERB> must be:
  </P>
  <VERBATIM><![CDATA[
[f]=fun(x, [optional parameters]).
   ]]></VERBATIM>
  <P>
    Here, <VERB>fun</VERB> is a function from R^n to R^m which returns <VERB>f(x)</VERB>, a
    real vector ( value of function at <VERB>x</VERB>) 
  </P>
  <P>
    If fun is defined by a Fortran or C routine first argument must be a
    list:
    \list(fun_name,m,...)
    If <VERB>fun_name</VERB> is a character string, it refers to the name of the routine
    which must be linked to Scilab. 
  </P>
  <P>
    Here, the generic calling sequence is: 
    In Fortran
  </P>
  <VERBATIM><![CDATA[
      subroutine fun(n,m,x,td,f)
      integer n,m
      double precision x(n), td(*), f(m)
   ]]></VERBATIM>
  <P>
    In C
  </P>
  <VERBATIM><![CDATA[
      void fun(int *n,int *m, double *x,double *params, double *f)
   ]]></VERBATIM>
  <P>
  </P>
  <P>
  </P>
  <P>
  </P>
  <P>
    <VERB>n</VERB> is the dimension of <VERB>x</VERB>, <VERB>x</VERB> is an <VERB>n</VERB> vector, 
    <VERB>td</VERB> are working arrays which may also be used to pass parameters
  </P>
  <P>
  </P>
  <P>
    If <VERB>fun</VERB> is given as a Fortran routine, it is possible to initialize
    parameters or to send Scilab variables to this routine using sequence
    of arguments <VERB>&apos;td&apos; , valtd</VERB>. Then, the Fortran function
    <VERB>fun(m,n , x, f, td)</VERB> is evaluated with  <VERB>td=valtd</VERB>.
    Thus, the Scilab variables  <VERB>valtd</VERB>  are sent to the Fortran
    function <VERB>fun</VERB>.
  </P>

  <DESCRIPTION_ITEM  label='Dfun'> 
    is an &quot;external&quot;.This external must return a matrix <VERB>g</VERB> such  as (<VERB>g(i,j)=dfi/dxj</VERB>) for a given <VERB>x</VERB>. 
  </DESCRIPTION_ITEM>
  <P>
    If <VERB>Dfun</VERB> is a function, the calling sequence for <VERB>fun</VERB> must be:
  </P>
  <VERBATIM><![CDATA[
[g]=Dfun(x, [optional parameters]).
   ]]></VERBATIM>
  <P>
    If Dfun is defined by a Fortran or C routine first argument must be a
    list:
    \list(fun_name,m,...)
    If <VERB>fun_name</VERB> is a character string, it refers to the name of the routine
    which must be linked to Scilab. This function has the same calling
    sequence as  <VERB>fun</VERB>
  </P>
  <P>
  </P>
  <P>
  </P>
 
  </DESCRIPTION>
  <ITEMIZE label='EXAMPLES'>
  <VERBATIM><![CDATA[

a=rand(3,2);b=[1;1;1];x0=[1;-1];
deff('f=fun(x,a,b)','f=a*x-b');
deff('g=dfun(x,a,b)','g=a');

[f,xopt]=leastsq(fun,x0)      //Simplest call
xopt-a\b  //compare with linear algebra solution

[f,xopt]=leastsq(fun,dfun,x0)      //specify gradient

[f,xopt]=leastsq(list(fun,[1 2;3 4],[1;2]),x0)    

deff('f=fun(x,a,b)','f=exp(a*x)-b');
deff('g=dfun(x,a,b)','g=a.*(exp(a*x)*ones(1,size(a,2)))');

[f,xopt]=leastsq(list(fun,[1 2;3 4],[1;2]),x0)  
   ]]></VERBATIM>
  </ITEMIZE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>external</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>quapro</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>linpro</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
