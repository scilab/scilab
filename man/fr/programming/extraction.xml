<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "../../man.dtd">
<MAN>
  <LANGUAGE>fr</LANGUAGE>
  <TITLE>extraction  </TITLE>
  <TYPE>Scilab Function  </TYPE>
  <DATE>September 1996  </DATE>
  <SHORT_DESCRIPTION name="extraction"> extraction à partir d&apos;une matrice ou d&apos;une liste  </SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>x(i,j)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>x(i)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[...]=l(i)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[...]=l(k1)...(kn)(i) ou [...]=l(list(k1,...,kn,i))  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>l(k1)...(kn)(i,j)   ou l(list(k1,...,kn,list(i,j))  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>x  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrice de tout type
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>l  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : liste
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>i,j  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : indices
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>k1,...kn  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : indices à valeurs entières
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
 

  <DESCRIPTION_ITEM  label='CAS DES MATRICES'> 
      <VERB>i</VERB> et <VERB>j</VERB> peuvent être :
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='-'> 
    des scalaires, vecteurs ou matrices à éléments positifs. 
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>r=x(i,j)</VERB> construit la matrice <VERB>r</VERB> telle que <VERB>r(l,k)=x(int(i(l)),int(j(k)))</VERB> pour <VERB>l</VERB> variant de 1 à <VERB>size(i,&apos;*&apos;)</VERB> et <VERB>k</VERB> variant de 1 à <VERB>size(j,&apos;*&apos;)</VERB>.   La valeur maximale de <VERB>i</VERB> (resp. <VERB>j</VERB>) doit être inférieure ou égale à <VERB>size(x,1)</VERB> (resp. <VERB>size(x,2)</VERB>).
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>r=x(i)</VERB> où <VERB>x</VERB> est une matrice 1 x 1, construit la matrice <VERB>r</VERB> telle que <VERB>r(l,k)=x(int(i(l)),int(i(k)))</VERB> pour <VERB>l</VERB> variant de 1 à <VERB>size(i,1)</VERB> et <VERB>k</VERB> variant de 1 à <VERB>size(i,2)</VERB>.   Noter que dans ce cas l&apos;indice <VERB>i</VERB> est valable si toutes ses composantes sont égales à 1.
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>r=x(i)</VERB> avec <VERB>x</VERB> un vecteur ligne, construit le vecteur ligne <VERB>r</VERB> tel que <VERB>r(l)=x(int(i(l)))</VERB> pour <VERB>l</VERB> entre 1 et <VERB>size(i,&apos;*&apos;)</VERB>  La valeur maximale de <VERB>i</VERB> doit être inférieure ou égale à <VERB>size(x,&apos;*&apos;)</VERB>.
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>r=x(i)</VERB> avec <VERB>x</VERB> une matrice à une ou plusieurs colonnes, construit la matrice  <VERB>r</VERB> telle que <VERB>r(l)</VERB> (<VERB>l</VERB> variant de 1 à <VERB>size(i,&apos;*&apos;)</VERB>) contient le terme numéro <VERB>int(i(l))</VERB> du vecteur colonne issu de la concaténation des colonnes de <VERB>x</VERB>.  La valeur maximale de <VERB>i</VERB> doit être inférieure ou égale à <VERB>size(x,&apos;*&apos;)</VERB>.
  </DESCRIPTION_ITEM>
 
  <P>
  </P>
  <P>
  </P>

  <DESCRIPTION_ITEM  label='-'> 
    Le symbole <VERB> : </VERB> signifiant &quot;tous les éléments&quot;. 
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>r=x(i,:)</VERB> construit la matrice <VERB>r</VERB> telle que <VERB>r(l,k)=x(int(i(l)),k))</VERB> pour <VERB>l</VERB> variant de 1 à <VERB>size(i,&apos;*&apos;)</VERB> et <VERB>k</VERB> variant de 1 à <VERB>size(x,2)</VERB>
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>r=x(:,j)</VERB> construit la matrice <VERB>r</VERB> telle que <VERB>r(l,k)=x(l,int(j(k)))</VERB> pour <VERB>l</VERB> variant de 1 à <VERB>size(r,1)</VERB> et <VERB>k</VERB> variant de 1 à <VERB>size(j,&apos;*&apos;)</VERB>.
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>r=x(:)</VERB> construit le vecteur colonne <VERB>r</VERB> obtenu par concaténation des colonnes  de <VERB> x</VERB>.  Cette commande est équivalente à <VERB>r=matrix(x,size(x,&apos;*&apos;),1)</VERB>.
  </DESCRIPTION_ITEM>
 
  <P>
  </P>
  <P>
  </P>

  <DESCRIPTION_ITEM  label='-'> 
    vecteur de booléens. Si un indice (<VERB>i</VERB>  ou <VERB>j</VERB> ) est un vecteur de booléen il est interprété comme <VERB>find(i)</VERB> ou <VERB>find(j)</VERB>, respectivement. 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='-'> 
    un polynôme. Si un indice (<VERB>i</VERB>  ou <VERB>j</VERB> ) est un vecteur de polynômes ou de polynômes implicites il est interprété comme <VERB>horner(i,m)</VERB> ou <VERB>horner(j,n)</VERB>, respectivement, où <VERB>m</VERB> et <VERB>n</VERB> sont les dimensions de <VERB>x</VERB> associées.  Même si cette fonctionnalité marche pour tous les polynômes, il est recommandé d&apos;utiliser des polynômes dans  <VERB>$</VERB> par souci de lisibilité.  
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label=''> 
    CAS DES LISTES (types LIST et TLIST)  S&apos;ils sont présents les <VERB>ki</VERB> donnent le chemin vers un terme d&apos;une sous-liste de la liste <VERB>l</VERB>. Ils permettent de faire une extraction récursive directe sans utiliser de variable intermédiaire.  Les instructions <VERB>[...]=l(k1)...(kn)(i)</VERB> et <VERB>[...]=l(list(k1,...,kn,i))</VERB> sont interprétées comme :  <VERB>lk1   = l(k1)</VERB>  <VERB> ..   = ..    </VERB>  <VERB>lkn   = lkn-1(kn)</VERB>  <VERB>[...] = lkn(i)</VERB>  De même, les instructions <VERB>l(k1)...(kn)(i,j)</VERB> et <VERB>l(list(k1,...,kn,list(i,j))</VERB> sont interprétées comme :  <VERB>lk1   = l(k1)</VERB>  <VERB> ..   = ..    </VERB>  <VERB>lkn   = lkn-1(kn)</VERB>  <VERB>        lkn(i,j)</VERB> <VERB>i</VERB> et <VERB>j</VERB>, peuvent valoir :  Quand le chemin désigne plusieurs termes d&apos;une liste l&apos;instruction doit avoir autant de termes dans la liste des arguments du membre de gauche que le nombre de termes sélectionnés. Mais si la syntaxe d&apos;extraction est utilisée dans les arguments d&apos;entrée d&apos;une fonction,  chaque terme renvoyé est ajouté aux arguments d&apos;entrée.
  </DESCRIPTION_ITEM>
  <P>
    Notez que <VERB> l(list()</VERB> est identique à <VERB>l</VERB>.
  </P>
 

  <DESCRIPTION_ITEM  label='-'> 
    scalaire, vecteur ou matrice à termes positifs    <VERB>[r1,...rn]=l(i)</VERB> extrait les termes <VERB>i(k)</VERB> de la liste l et les stocke dans les variables <VERB>rk</VERB> pour <VERB>k</VERB> variant de 1 à <VERB>size(i,&apos;*&apos;)</VERB> 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='-'> 
    le symbole <VERB> : </VERB> (&quot;tous les éléments&quot;) 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='-'> 
    vecteur de booléens. Si <VERB>i</VERB>  est un vecteur de booléens, il est interprété comme <VERB>find(i)</VERB>. 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='-'> 
    un polynôme. Si <VERB>i</VERB> est un vecteur de polynômes ou de polynômes implicites il est interprété comme <VERB>horner(i,m)</VERB> où <VERB>m=size(l)</VERB>.  Même si cette fonctionnalité marche pour tous les polynômes, il est recommandé d&apos;utiliser des polynômes dans  <VERB>$</VERB> par souci de lisibilité. 
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='k1,..kn peuvent être :'> 
    
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='-'> 
    un nombre réel positif  
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='-'> 
    un polynôme, interprété comme <VERB>horner(ki,m)</VERB> ou <VERB>m</VERB> est la taille de la sous-liste correspondante. 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='- une chaîne de caractères associée à un nom d&apos;entrée de sous-liste'> 
  </DESCRIPTION_ITEM>
 
 
  </DESCRIPTION>
  <ITEMIZE label='REMARQUES'>
  <P>
    Pour les matrices rationnelles et les systèmes dynamiques linéaires stockés sous forme de représentation d&apos;état, la syntaxe <VERB>x(i)</VERB> ne doit pas être utilisée pour l&apos;extraction des éléments d&apos;un vecteur, à cause de la confusion possible avec l&apos;extraction des éléments de liste. La syntaxe <VERB>x(1,j)</VERB> où <VERB>x(i,1)</VERB> doit être utilisée dans ce cas.
  </P>
  </ITEMIZE>
  <EXAMPLE><![CDATA[
// CAS DES MATRICES
a=[1 2 3;4 5 6]
a(1,2)
a([1 1],2)
a(:,1)
a(:,3:-1:1)
a(1)
a(6)
a(:)
a([%t %f %f %t])
a([%t %f],[2 3])
a(1:2,$-1)
a($:-1:1,2)
a($)
//
x='test'
x([1 1;1 1;1 1])
//
b=[1/%s,(%s+1)/(%s-1)]
b(1,1)
b(1,$)
b(2) // le numérateur
// CAS des LISTES (types LIST et TLIST)
l=list(1,'qwerw',%s)
l(1)
[a,b]=l([3 2])
l($)
x=tlist(l(2:3)) // construction d'une TLIST avec les deux derniers termes de l
//
dts=list(1,tlist(['x';'a';'b'],10,[2 3]));
dts(2)('a')
dts(2)('b')(1,2)
[a,b]=dts(2)(['a','b'])

 ]]></EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>find</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>horner</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>parents</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
