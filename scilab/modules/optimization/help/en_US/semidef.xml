<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * Copyright (C) 2011 - DIGITEO - Michael Baudin
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry version="5.0-subset Scilab" xml:id="semidef" xml:lang="en"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:ns4="http://www.w3.org/1999/xhtml"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <pubdate>
      $LastChangedDate: 2008-03-26 09:50:39 +0100 (mer, 26 mar 2008)
      $
    </pubdate>
  </info>

  <refnamediv>
    <refname>semidef</refname>

    <refpurpose>semidefinite programming</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Calling Sequence</title>

    <synopsis>[x,Z,ul,info]=semidef(x0,Z0,F,blck_szs,c,options)</synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Arguments</title>

    <variablelist>
      <varlistentry>
        <term>x0</term>

        <listitem>
          <para>
            m-by-1 real column vector (must be strictly primal feasible,
            see below)
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Z0</term>

        <listitem>
          <para>
            L-by-1 real vector (compressed form of a strictly feasible dual
            matrix, see below)
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>F</term>

        <listitem>
          <para>L-by-(m+1) real matrix</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>blck_szs</term>

        <listitem>
          <para>
            p-by-2 integer matrix (sizes of the blocks) defining the
            dimensions of the (square) diagonal blocks
            <literal>size(Fi(j)=blck_szs(j) j=1,...,m+1</literal>.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>c</term>

        <listitem>
          <para>m-by-1 real vector</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>options</term>

        <listitem>
          <para>
            a 1-by-5 matrix of doubles <literal>[nu,abstol,reltol,tv,maxiters]</literal>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>ul</term>

        <listitem>
          <para>a 1-by-2 matrix of doubles.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>

  <refsection>
    <title>Description</title>

    <para>
      <literal>semidef</literal> solves the semidefinite program:
    </para>

    <informalequation>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="../mml/semidef_equation_1.mml" />
        </imageobject>
      </mediaobject>
    </informalequation>

    <para>and its dual:</para>

    <informalequation>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="../mml/semidef_equation_2.mml" />
        </imageobject>
      </mediaobject>
    </informalequation>

    <para>
      exploiting block structure in the matrices
      <literal>F_i</literal>.
    </para>

    <para>
      The <literal>Fi's</literal> matrices are stored columnwise in
      <literal>F</literal> in compressed format: if <literal>F_i^j</literal>,
      i=0,..,m, j=1,...,L denote the jth (symmetric) diagonal block of
      <literal>F_i</literal>, then
    </para>

    <informalequation>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="../mml/semidef_equation_3.mml" />
        </imageobject>
      </mediaobject>
    </informalequation>

    <para>
      where <literal>pack(M)</literal>, for symmetric
      <literal>M</literal>, is the vector
      <literal>[M(1,1);M(1,2);...;M(1,n);M(2,2);M(2,3);...;M(2,n);...;M(n,n)]</literal>
      (obtained by scanning rowwise the upper triangular part of
      <literal>M</literal>).
    </para>

    <para>
      <literal>blck_szs</literal> gives the size of block
      <literal>j</literal>, ie,
      <literal>size(F_i^j)=blck_szs(j)</literal>.
    </para>

    <para>
      Z is a block diagonal matrix with L blocks <literal>
        Z^0, ...,
        Z^{L-1}
      </literal>. <literal>Z^j</literal> has size <literal>
        blck_szs[j]
        times blck_szs[j]
      </literal>. Every block is stored using packed storage of
      the lower triangular part.
    </para>

    <para>
      The 1-by-2 matrix of doubles <literal>ul</literal> contains the primal objective
      value <literal>c'*x</literal> and the dual objective value
      <literal>-trace(F_0*Z</literal>).
    </para>

    <para>
      The entries of <literal>options</literal> are respectively:
      <itemizedlist>
        <listitem>
          <para>
            <literal>nu</literal>: a real parameter which ntrols the rate of
            convergence.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>abstol</literal>: absolute tolerance.
            The absolute tolerance cannot be lower than 1.0e-8,
            that is, the absolute tolerance used in the algorithm is the maximum of
            the user-defined tolerance and the constant tolerance 1.0e-8.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>reltol</literal>: relative tolerance (has a special meaning when
            negative).
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>tv</literal>: the target value, only referenced if
            <literal>reltol &lt; 0</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>maxiters</literal>: the maximum number of iterations, a positive integer value.
          </para>
        </listitem>
      </itemizedlist>

    </para>

    <para>
      On output, the <literal>info</literal> variable contains the status of the execution.
      <itemizedlist>
        <listitem>
          <para>
            <literal>info=1</literal> if maxiters exceeded,
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>info=2</literal> if absolute accuracy is reached,
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>info=3</literal> if relative accuracy is reached,
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>info=4</literal> if target value is reached,
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>info=5</literal> if target value is not achievable;
          </para>
        </listitem>
        <listitem>
          <para>
            negative values indicate errors.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Convergence criterion is based on the following conditions that is, the
      algorithm stops if one of the following conditions is true:
      <itemizedlist>
        <listitem>
          <para>
            maxiters is exceeded
          </para>
        </listitem>
        <listitem>
          <para>
            duality gap is less than abstol
          </para>
        </listitem>
        <listitem>
          <para>
            primal and dual objective are both positive and
            duality gap is less than (<literal>reltol</literal> * dual objective)
            or primal and dual objective are both negative and
            duality gap is less than (<literal>reltol</literal> * minus the primal objective)
          </para>
        </listitem>
        <listitem>
          <para>
            reltol is negative and
            primal objective is less than tv or dual objective is greater
            than <literal>tv</literal>.
          </para>
        </listitem>
      </itemizedlist>
    </para>

  </refsection>
  <refsection>
    <title>Implementation notes</title>
    <para>
      This function is based on L. Vandenberghe and S. Boyd sp.c program.
    </para>

  </refsection>

  <refsection>
    <title>Examples</title>

    <programlisting role="example">
      <![CDATA[ 
F0=[2,1,0,0;
    1,2,0,0;
    0,0,3,1
    0,0,1,3];

F1=[1,2,0,0;
    2,1,0,0;
    0,0,1,3;
    0,0,3,1]

F2=[2,2,0,0;
    2,2,0,0;
    0,0,3,4;
    0,0,4,4];

blck_szs=[2,2];

F01=F0(1:2,1:2);F02=F0(3:4,3:4);
F11=F1(1:2,1:2);F12=F1(3:4,3:4);
F21=F2(1:2,1:2);F22=F2(3:4,3:4);

x0=[0;0]
Z0=2*F0;
Z01=Z0(1:2,1:2);Z02=Z0(3:4,3:4);
FF=[[F01(:);F02(:)],[F11(:);F12(:)],[F21(:);F22(:)]]
ZZ0=[[Z01(:);Z02(:)]];

c=[trace(F1*Z0);trace(F2*Z0)];
options=[10,1.d-10,1.d-10,0,50];

[x,Z,ul,info]=semidef(x0,pack(ZZ0),pack(FF),blck_szs,c,options)

w=vec2list(unpack(Z,blck_szs),[blck_szs;blck_szs]);
Z=sysdiag(w(1),w(2))

c'*x+trace(F0*Z)
spec(F0+F1*x(1)+F2*x(2))
trace(F1*Z)-c(1)
trace(F2*Z)-c(2)
 ]]>
    </programlisting>
  </refsection>

  <refsection>
    <title>References</title>

    <para>
      L. Vandenberghe and S. Boyd, " Semidefinite Programming,"
      Informations Systems Laboratory, Stanford University, 1994.
    </para>

    <para>
      Ju. E. Nesterov and M. J. Todd, "Self-Scaled Cones and
      Interior-Point Methods in Nonlinear Programming," Working Paper, CORE,
      Catholic University of Louvain, Louvain-la-Neuve, Belgium, April
      1994.
    </para>

    <para>
      SP: Software for Semidefinite Programming, <ulink
    url="http://www.ee.ucla.edu/~vandenbe/sp.html">http://www.ee.ucla.edu/~vandenbe/sp.html</ulink>
    </para>
  </refsection>
</refentry>
