<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>

<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->

<!DOCTYPE MAN SYSTEM "../../../../modules/helptools/help.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>graph_union</TITLE>
  <TYPE>Scilab function</TYPE>
  <DATE>$LastChangedDate$</DATE>
  <SHORT_DESCRIPTION name="graph_union"> union of two graphs</SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
    <CALLING_SEQUENCE_ITEM>g2 = graph_union(g,g1 [,opt])  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
        <PARAM_NAME>g</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>:  a <LINK>graph_data_structure</LINK>.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>g1</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: a graph data structure.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>opt</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: a boolean, with  <VERB>%t</VERB> as default value.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>g2</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: graph data structure of the new graph</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <SP><VERB>graph_union(g,g1)</VERB> creates a new graph
    <VERB>g2</VERB>. The node set of <VERB>g2</VERB> is the union (in
    the usual sense) of the node sets of <VERB>g</VERB> and
    <VERB>g1</VERB>. If node names are given in both graph, nodes with
    equal names in <VERB>g1</VERB> and <VERB>g2</VERB> are considered
    as common nodes. </SP>
    <P><VERB>g2</VERB> has an edge for each edge of <VERB>g</VERB> and
    an edge for each edge of <VERB>g1</VERB>. The edges of
    <VERB>g</VERB> and <VERB>g1</VERB> having the same endpoints are
    kept and in this case <VERB>g2</VERB> has multiple edges.</P>
    </DESCRIPTION_ITEM>
    <DESCRIPTION_ITEM>
    <SP><VERB>graph_union(g,g1,%f)</VERB> creates a new graph
    <VERB>g2</VERB>. The node set of <VERB>g2</VERB> is the union (in
    the usual sense) of the node sets of t<VERB>g</VERB> and
    <VERB>g1</VERB>. In this case the function does not looks for
    common nodes.</SP>
    <P><VERB>g2</VERB> has an edge for each edge of <VERB>g</VERB> and an edge for each edge of 
    <VERB>g1</VERB>. The edges of <VERB>g</VERB> and <VERB>g1</VERB> having the same endpoints are kept 
    and in this case <VERB>g2</VERB> has multiple edges.</P>
    </DESCRIPTION_ITEM>

  </DESCRIPTION_INDENT>
  </DESCRIPTION>
  <EXAMPLE>
<![CDATA[
ta1=[1,2,3,4,4,4,4,5,6,7,7];he1=[2,3,1,1,5,7,7,6,7,3,4];
g1=make_graph('foo1',1,7,ta1,he1);
g1.nodes.graphics.x= [273,271,339,384,504,513,439];
g1.nodes.graphics.y= [221,324,432,141,209,319,428];
g1.nodes.graphics.display= 'name';
g1.nodes.graphics.name= ['A' 'B' 'C' 'D' 'E' 'F' 'G'];
w1=show_graph(g1);

ta2=[1,1,2,2,3,5,6,6,7,8];he2=[2,8,3,5,4,6,4,7,5,5];
g2=make_graph('foo2',1,8,ta2,he2);
g2.nodes.graphics.x= [233,113,114,114,223,221,289,334];
g2.nodes.graphics.y= [59, 133,227,319,221,324,432,141];
g2.nodes.graphics.name= ['H' 'I' 'J' 'K' 'A' 'B' 'C' 'D'];
g2.nodes.graphics.display= 'name';
w2=show_graph(g2,'new');


g=graph_union(g1,g2);
show_graph(g,'new');

g=graph_union(g1,g2,%f);
show_graph(g,'new');

 ]]>
  </EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM>
      <LINK>supernode</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>subgraph</LINK>
    </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
