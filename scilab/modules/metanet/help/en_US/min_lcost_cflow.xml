<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>

<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->

<!DOCTYPE MAN SYSTEM "../../../../modules/helptools/help.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>min_lcost_cflow</TITLE>
  <TYPE>Scilab function</TYPE>
  <DATE>$LastChangedDate$</DATE>
  <SHORT_DESCRIPTION name="min_lcost_cflow"> minimum linear cost constrained flow</SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
    <CALLING_SEQUENCE_ITEM>[c,phi,v,flag] = min_lcost_cflow(i,j,cv,g)  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
        <PARAM_NAME>i</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer, source node number</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>j</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer, sink node number</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>cv</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: scalar, value of constrained flow</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>g</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>:  a <LINK>graph_data_structure</LINK>.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>c</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: value of cost</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>phi</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: row vector of the values of flow on the arcs</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>v</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: value of flow from source to sink</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>flag</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: feasible constrained flow flag (0 or 1)</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
    <P><VERB>min_lcost_cflow</VERB> computes the minimum cost flow in
    the network <VERB>g</VERB>, with the value of the flow from source
    node <VERB>i</VERB> to sink node <VERB>j</VERB> constrained to be
    equal to <VERB>cv</VERB>.</P>
    <P><VERB>min_lcost_cflow</VERB> returns the total cost of the flows on the arcs <VERB>c</VERB>,
    the row vector of the flows on the arcs <VERB>phi</VERB> and the value of the flow 
    <VERB>v</VERB> on the virtual arc from sink to source. If <VERB>v</VERB> is less than 
    <VERB>cv</VERB>, a message is issued, but the computation is done: in this
    case <VERB>flag</VERB> is equal to 0, otherwise it is equal to 1.</P>
    <P>
    The bounds of the flows are given by the 
     <VERB>max_cap</VERB> fields of the
    <LINK>edges_data_structure</LINK>.  The value of the maximum
    capacity must be non negative and must be integer numbers.  If the
    values of <VERB>max_cap</VERB> is not
    given, they are assumed to be equal to 0 on each edge.</P>
    <P>
    The costs on the edges are given by the  <VERB>cost</VERB> field
    of the <LINK>edges_data_structure</LINK>.  The costs must be non
    negative.  If the value of <VERB>cost</VERB> is not given, it is
    assumed to be equal to 0 on each edge.</P>
   
    <P>
    This function uses the algorithm of Busacker and Goven.</P>
  </DESCRIPTION>
  <EXAMPLE>
<![CDATA[
ta=[1 1 2 2 2 3 4 4 5 6 6 6 7 7 7 8 9 10 12 12 13 13 13 14 15 14 9 11 10];
he=[2 6 3 4 5 1 3 5 1 7 10 11 5 8 9 5 8 11 10 11 9 11 15 13 14 4 6 9 1];
g=make_graph('foo',1,15,ta,he);
g.nodes.graphics.x=[155,153,85,155,237,244,244,334,338,346,442,440,439,333,438];
g.nodes.graphics.y=[45,145,221,222,221,82,139,225,142,69,140,72,232,318,319];
source=15;g.nodes.graphics.type(source)=2; //source node
sink=1;g.nodes.graphics.type(sink)=1; //sink node
show_graph(g);

g=add_edge_data(g,'max_cap',[11,8,9,19,20,8,9,16,6,11,6,12,12,3,6,14,16,2,14,5,9,18,13,11,5,18,3,7,18]);
g=add_edge_data(g,'cost',[9,6,11,7,11,2,8,5,7,10,2,9,10,7,7,9,2,7,2,8,4,6,11,8,1,7,4,4,7]);
flow_constraint=5;
[c,phi,v,flag]=min_lcost_cflow(source,sink,flow_constraint,g);

g.edges.graphics.foreground(find(phi<>0))=color('red');
g=add_edge_data(g,'flow',phi)
g.edges.graphics.display='flow';
show_graph(g);
 ]]>
  </EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM>
      <LINK>max_flow</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>min_lcost_flow1</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>min_lcost_flow2</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>min_qcost_flow</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>edges_data_structure</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>add_edge_data</LINK>
    </SEE_ALSO_ITEM>

    <SEE_ALSO_ITEM>
      <LINK>nodes_data_structure</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>add_node_data</LINK>
    </SEE_ALSO_ITEM>
   
  </SEE_ALSO>
</MAN>
