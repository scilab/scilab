<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>

<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->

<!DOCTYPE MAN SYSTEM "../../../../modules/helptools/help.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>min_qcost_flow</TITLE>
  <TYPE>Scilab function</TYPE>
  <DATE>$LastChangedDate$</DATE>
  <SHORT_DESCRIPTION name="min_qcost_flow"> minimum quadratic cost flow</SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
    <CALLING_SEQUENCE_ITEM>[c,phi,flag] = min_qcost_flow(eps,g)  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
        <PARAM_NAME>eps</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: scalar, precision</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>g</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>:  a <LINK>graph_data_structure</LINK>.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>c</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: value of cost</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>phi</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: row vector of the value of flow on the arcs</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>flag</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: feasible problem flag (0 or 1)</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
    <P><VERB>min_qcost_flow</VERB> computes the minimum quadratic cost
    flow in the network <VERB>g</VERB>. It returns the total cost of
    the flows on the arcs <VERB>c</VERB> and the row vector of the
    flows on the arcs <VERB>phi</VERB>. <VERB>eps</VERB> is the
    precision of the iterative algorithm. If the problem is not
    feasible (impossible to find a compatible flow for instance),
    <VERB>flag</VERB> is equal to 0, otherwise it is equal to 1.</P>
    
    <P>The bounds of the flow are given by the<VERB>min_cap</VERB> and
    <VERB>max_cap</VERB> fielgs of the graph
    <LINK>edges_data_structure</LINK>.  The value of the maximum
    capacity must be greater than or equal to the value of the minimum
    capacity.  If the value of <VERB>min_cap</VERB> or
    <VERB>max_cap</VERB> is not given , it is assumed to be equal to 0
    on each edge.</P>
   
    <P>The costs on the edges are given by the elements
    <VERB>q_orig</VERB> and <VERB>q_weight</VERB> of the graph
    <LINK>edges_data_structure</LINK>. The cost on arc <VERB>u</VERB>
    is given by:</P>
    <P>
      <VERB>(1/2)*q_weight[u](phi[u]-q_orig[u])^2</VERB>
    </P>
    <P>The costs must be non negative.  If the value of
    <VERB>q_orig</VERB> or <VERB>q_weight</VERB> is not given, it is
    assumed to be equal to 0 on each edge.</P>
    
    <P>This function uses an algorithm due to M. Minoux.</P>
  </DESCRIPTION>
  <EXAMPLE>
<![CDATA[
ta=[1 1 2 2 2 3 4 4 5 6 6 6 7 7 7 8 9 10 12 12 13 13 13 14 15 14 9 11 10 1 8];
he=[2 6 3 4 5 1 3 5 1 7 10 11 5 8 9 5 8 11 10 11 9 11 15 13 14 4 6 9 1 12 14];
g=make_graph('foo',1,15,ta,he);
g.nodes.graphics.x=[155,153,85,155,237,244,244,334,338,346,442,440,439,333,438];
g.nodes.graphics.y=[45,177,253,254,253,114,171,257,174,101,172,64,264,350,351];
show_graph(g);

ma=edge_number(g)
g=add_edge_data(g,'min_cap',[0,1,5,5,0,3,3,5,4,1,4,3,3,1,3,1,1,4,1,3,1,4,5,4,4,2,1,4,2,3,2]);
g=add_edge_data(g,'max_cap',[38,37,42,41,34,49,35,36,43,43,43,48,37,..
                                 36,42,48,44,36,30,31,30,41,32,42,34,48,32,36,36,36,30]);
g=add_edge_data(g,'q_weight',ones(1,ma));
[c,phi,flag]=min_qcost_flow(0.001,g);flag

g.edges.graphics.foreground(find(phi<>0))=color('red');
g=add_edge_data(g,'flow',phi)
g.edges.graphics.display='flow';
show_graph(g);


 ]]>
  </EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM>
      <LINK>min_lcost_cflow</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>min_lcost_flow1</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>min_lcost_flow2</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>edges_data_structure</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>add_edge_data</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>nodes_data_structure</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>add_node_data</LINK>
    </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
