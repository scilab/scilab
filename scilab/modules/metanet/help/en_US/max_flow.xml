<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry version="5.0-subset Scilab" xml:id="max_flow" xml:lang="en"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:ns3="http://www.w3.org/1999/xhtml"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <pubdate>$LastChangedDate$</pubdate>
  </info>

  <refnamediv>
    <refname>max_flow</refname>

    <refpurpose>maximum flow between two nodes</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Calling Sequence</title>

    <synopsis>[v,phi,flag] = max_flow(i,j,g)</synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Parameters</title>

    <variablelist>
      <varlistentry>
        <term>i</term>

        <listitem>
          <para>integer, number of start node</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>j</term>

        <listitem>
          <para>integer, number of end node</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>g</term>

        <listitem>
          <para>a <link
          linkend="graph_data_structure">graph_data_structure</link>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>v</term>

        <listitem>
          <para>value of the maximum flow it is exists</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>phi</term>

        <listitem>
          <para>row vector of the value of the flow on the arcs</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>flag</term>

        <listitem>
          <para>feasible problem flag (0 or 1)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>

  <refsection>
    <title>Description</title>

    <para><literal>max_flow</literal> returns the value of maximum flow
    <literal>v</literal> from node number <literal>i</literal> to node number
    <literal>j</literal> if it exists, and the value of the flow on each arc
    as a row vector <literal>phi</literal>. All the computations are made with
    integer numbers. The graph must be directed. If the problem is not
    feasible, <literal>flag</literal> is equal to 0, otherwise it is equal to
    1.</para>
   <para>
      The bounds of the flow are given by the
      <literal>g.edges.data.min_cap</literal> and
      <literal>g.edges.data.max_cap</literal> fields of the graph.
    </para>
    <para>
      The value of the minimum capacity and of the maximum capacity
      must be non negative.  The value of
      the maximum capacity must be greater than or equal to the value
      of the minimum capacity. 
    </para>
    <para> 
      If the value of
      <literal>min_cap</literal> or <literal>max_cap</literal> is not
      given it is assumed to be equal to 0 on each edge.</para>
   
    <para>
      If the <literal>min_cap</literal> or <literal>max_cap</literal>
      data fields are not present in the
      graph structure they can be added and set using the <link
      linkend="add_edge_data">add_edge_data</link> function.
    </para>
  

  </refsection>

  <refsection>
    <title>Examples</title>

    <programlisting role="example">

ta=[1 1 2 2 3 3 4 4 5 5 5 5 6 6 6 7 7 15 15 15 15 15 15 15 8 9 10 11 12 13 14];
he=[10 13 9 14 8 11 9 11 8 10 12 13 8 9 12 8 11 1 2 3 4 5 6 7 16 16 16 16 16 16 16];
g=make_graph('foo',1,16,ta,he);
g.nodes.graphics.x=[53,430,202,374,116,250,325,176,373,34,330,233,114,429,208,206];
g.nodes.graphics.y=[86,114,115,129,118,122,133,222,222,221,214,219,218,246,40,301];
ma=edge_number(g);
g=add_edge_data(g,'max_cap',[2,4,3,3,3,2,3,3,5,2,3,1,2,1,4,1,2,2,2,2,4,1,5,3,2,1,5,4,3,4,2]);
g=add_edge_data(g,'min_cap',ones(1,ma))
source=15;g.nodes.graphics.type(source)=2; //source node
sink=16;g.nodes.graphics.type(sink)=1; //sink node
show_graph(g);

[v,phi,ierr]=max_flow(source,sink,g);
g.edges.graphics.foreground(phi&lt;&gt;0)=11;
g=add_edge_data(g,'flow',phi)
g.edges.graphics.display='flow';
show_graph(g);
 
  </programlisting>
  </refsection>

  <refsection>
    <title>See Also</title>

    <simplelist type="inline">
      <member><link linkend="min_lcost_flow1">min_lcost_flow1</link></member>

      <member><link linkend="min_lcost_flow2">min_lcost_flow2</link></member>

      <member><link linkend="min_qcost_flow">min_qcost_flow</link></member>

      <member><link
      linkend="edges_data_structure">edges_data_structure</link></member>

      <member><link linkend="add_edge_data">add_edge_data</link></member>
    </simplelist>
  </refsection>
</refentry>
