/*
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2010 - DIGITEO - Allan SIMON
 * Copyright (C) 2010 - DIGITEO - Bruno JOFRET
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 */

package org.scilab.modules.ui_data.variableeditor.celleditor;

import static org.scilab.modules.action_binding.highlevel.ScilabInterpreterManagement.asynchronousScilabExec;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.text.ParseException;

import javax.swing.AbstractAction;
import javax.swing.DefaultCellEditor;
import javax.swing.JFormattedTextField;
import javax.swing.JTable;
import javax.swing.KeyStroke;

import org.scilab.modules.action_binding.highlevel.ScilabInterpreterManagement.InterpreterException;
import org.scilab.modules.ui_data.variableeditor.ScilabVariableEditor;

public abstract class ScilabGenericCellEditor extends DefaultCellEditor {
    /**
     * 
     */
    private static final long serialVersionUID = -5713675180587317165L;

    protected int row;
    protected int col;
    protected JFormattedTextField textField;

    public ScilabGenericCellEditor() {
        super(new JFormattedTextField());

        textField = (JFormattedTextField) getComponent();
        textField.setFocusLostBehavior(JFormattedTextField.COMMIT);

        textField.getInputMap().put(KeyStroke .getKeyStroke(KeyEvent.VK_ENTER, 0),"check");
        textField.getInputMap().put(KeyStroke .getKeyStroke(KeyEvent.VK_TAB, 0),"check");
        textField.getActionMap().put("check", new CellContentCheck());
    }

    /**
     * CellContentCheck
     * Called when user try to validate current cell content with TAB or ENTER
     */
    private class CellContentCheck extends AbstractAction {

        public void actionPerformed(ActionEvent e) {
            String request = buildScilabRequest();
            callScilabValidationOfCellContent(request);
        }

        /**
         * Execute the request generated by buildScilabRequest, it will check and interprete the content of the cell
         * and return the result back to EditVar
         * @param request the request to be executed by Scilab
         */
        private void callScilabValidationOfCellContent(String request) {
            final ActionListener action = new ActionListener() {

                public void actionPerformed(ActionEvent e) {

                }
            };

            try {
                asynchronousScilabExec(action, request);
            } catch (InterpreterException e1) {
                System.err.println("An error in the interpreter has been catched: " + e1.getLocalizedMessage()); 
            }

            try {
                textField.commitEdit();
                textField.postActionEvent();
            } catch (ParseException e1) {
                System.err.println("An error in the parser has been catched: " + e1.getLocalizedMessage()); 
            }
        }
    }

    private String buildScilabRequest() {

        final StringBuilder command = new StringBuilder();
        String variableName = ScilabVariableEditor.getVariableEditor().getVariablename();
        String data = getDataAsScilabString();
        
        String cellInVariable = variableName + "(" + row + "," + col + ")";
        
        // Manage Special transtyping case :
        // a = 1 then a = "plop"
        // only occurs when editing a scalar variable at index (1, 1)
        
        StringBuilder cmdInExecStr = new StringBuilder();
        cmdInExecStr.append("if (" + row + " == 1 & " + col + " == 1 & size(" + variableName + ",\"\"*\"\") == 1" + ") ");
        cmdInExecStr.append("then " + variableName + " = " + data + "; ");
        cmdInExecStr.append("else " + cellInVariable + " = " + data + "; end");
        
		command.append("if execstr(\"" + cmdInExecStr.toString() + "\", \"errcatch\") <> 0 then ");
		command.append("messagebox(\"Could not edit variable: \" + lasterror() + \"\"");
		command.append(",\"Variable editor\", \"error\", \"modal\");");
		command.append("end ");
        command.append("updateEditvarValue(\"" + variableName + "\"," + row + "," + col + "," + cellInVariable + ", 0);");

        return command.toString();
    }

    protected String getDataAsScilabString() {
        String data = String.valueOf(textField.getText());

        data = data.replace("\"", "\"\"\"\""); // Change " to """" because added in an execstr command
        data = data.replace("'", "''''"); // Change ' to '''' because added in an execstr command

        return data;
    }

    /**
     * {@inheritDoc}
     */
    public Component getTableCellEditorComponent(JTable table, Object value,
            boolean isSelected, int row, int col) {
        this.row = row + 1; // +1 because scilab index start at 1
        this.col = col + 1;

        return super.getTableCellEditorComponent(table, value, isSelected, row, col);
    }

	public Component getTableCellEditorComponent(JTable table) {
		// TODO Auto-generated method stub
		return null;
	}

}
