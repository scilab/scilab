<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "../../manrev.dtd">
<MAN>
  <LANGUAGE>fr</LANGUAGE>
  <TITLE>grand  </TITLE>
  <TYPE>Scilab Function  </TYPE>
  <DATE>Dec 1997  </DATE>
  <SHORT_DESCRIPTION name="grand"> Générateur(s) de nombres pseudo-aléatoires</SHORT_DESCRIPTION>

  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>Y=grand(m, n, dist_type [,p1,...,pk])  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>Y=grand(X, dist_type [,p1,...,pk])  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>Y=grand(n, dist_type [,p1,...,pk])  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>S=grand(action [,q1,....,ql])  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>


  <PARAM>
  <PARAM_INDENT>

  <PARAM_ITEM>
  <PARAM_NAME>m, n</PARAM_NAME>
  <PARAM_DESCRIPTION>
  <SP>
   : entiers, dimensions de la matrice de nombres aléatoires à obtenir <VERB>Y</VERB>
</SP>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>X </PARAM_NAME>
  <PARAM_DESCRIPTION>
  <SP>
   : une matrice (ou un vecteur) dont seules les dimensions (<VERB>m x n</VERB>) sont utilisées
</SP>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>dist_type</PARAM_NAME>
  <PARAM_DESCRIPTION>
  <SP>
   : chaîne de caractères donnant la loi de distribution des nombres aléatoires ('bin', 'nor', 'poi', etc ...)
</SP>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>p1, ..., pk</PARAM_NAME>
  <PARAM_DESCRIPTION>
  <SP>
  : les (éventuels) paramètres de la distribution <VERB>dist_type</VERB>
</SP>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>Y</PARAM_NAME>
  <PARAM_DESCRIPTION>
  <SP>
   : la matrice de nombres aléatoires <VERB>m x n</VERB>
</SP>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>action</PARAM_NAME>
  <PARAM_DESCRIPTION>
  <SP>
   : chaîne de caractères spécifiant l'action à entreprendre sur le générateur de base ('setgen' pour changer
     le générateur courant, 'getgen' pour obtenir le nom du générateur courant, 'getsd' pour obtenir l'état
     du générateur courant, etc...).
</SP>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>q1, ..., ql</PARAM_NAME>
  <PARAM_DESCRIPTION>
  <SP>
  : les paramètres  (éventuels) de l'action à effectuer sur le générateur de base.
</SP>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>S</PARAM_NAME>
  <PARAM_DESCRIPTION>
  <SP>
   : résultat de l'action (en général une chaîne ou un vecteur colonne)
</SP>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  </PARAM_INDENT>
  </PARAM>

  <DESCRIPTION>
  <P>
     Cette fonction peut être utilisée pour générer des nombres pseudo-aléatoires à partir
     d'une loi de distribution donnée (binomiale, uniforme, normale,...) : ces nombres peuvent
     être considérés comme des réalisations de variables aléatoires indépendantes qui suivent
     la loi donnée. Dans ce cas vous devez appliquer l'une des <EM>trois premières séquences 
     d'appel</EM> pour obtenir une matrice <VERB>m x n</VERB> de tels nombres. La deuxième 
     séquence est équivalente à la première si <VERB>X</VERB> est une matrice <VERB>m x n</VERB> 
     et la troisième forme s'applique lorsque la loi est vectorielle (comme la loi multinomiale) :
     une réalisation correspond alors à un vecteur colonne (de dimension <VERB>m</VERB>) et 
     l'on obtient ainsi <VERB>n</VERB> réalisations sous la forme d'une matrice
      <VERB>m x n</VERB>. 

  </P> 
  <P>
     <EM>La dernière forme d'appel</EM> s'utilise pour entreprendre diverses actions sur 
     le générateur de base (depuis la version 2.7 vous pouvez choisir parmi plusieurs 
     générateurs comme Mersenne-Twister, KISS, clcg4, ...). Ces générateurs fournissent 
     des entiers selon une loi uniforme sur un intervalle très grand (distribution lgi), 
     les autres types de lois s'obtenant à partir de ces générateurs de base 
     (en général suivant un schéma lgi -> U([0,1)) -> distribution cherchée).
  </P>
  </DESCRIPTION>


  <SECTION  label='Générer des nombres aléatoires selon une loi donnée'>
  <ITEMIZE>
   <ITEM label='beta'>
<SP>   : <VERB>Y=grand(m,n,'bet',A,B)</VERB> génère des nombres aléatoires suivant 
     la loi beta de paramètres <VERB>A</VERB> and <VERB>B</VERB>. 
     La densité de cette loi est (<VERB>0 &lt; x &lt; 1</VERB>) :</SP>
     <VERBATIM><![CDATA[
          A-1    B-1
         x   (1-x)   / beta(A,B)  ( beta(A,B) = gamma(A+B) / (gamma(A) gamma(B)) )
     ]]></VERBATIM>
     <SP><VERB>A</VERB> et <VERB>B</VERB> devant être des réels &gt; 10^(-37).
     Fonction(s) associée(s) : <LINK>cdfbet</LINK>.</SP>
  </ITEM>

  <ITEM label='binomiale'>
<SP>   : <VERB>Y=grand(m,n,'bin',N,p)</VERB>  génère des nombres aléatoires suivant la loi
     binomiale de paramètres <VERB>N</VERB> (entier str. positif) et <VERB>p</VERB>
     (réel de [0,1]) : nombre de succès au cours de <VERB>N</VERB> épreuves de Bernouilli
     de probabilité de succès <VERB>p</VERB>.
     Fonction(s) associée(s) : <LINK>binomial</LINK>, <LINK>cdfbin</LINK>.</SP>
  </ITEM>

  <ITEM label='binomiale négative'>
<SP>   : <VERB>Y=grand(m,n,'nbn',N,p)</VERB> génère des nombres aléatoires suivant la loi binomiale
     négative de paramètres <VERB>N</VERB> (entier str. positif) et <VERB>p</VERB> (réel 
     de ]0,1[) : nombre d'échecs avant d'obtenir <VERB>N</VERB> succès dans des épreuves
     de Bernouilli de probabilité de succès <VERB>p</VERB>.
     Fonction(s) associée(s) : <LINK>cdfnbn</LINK>.</SP>
  </ITEM>

  <ITEM label='chi 2'>
<SP>   : <VERB>Y=grand(m,n,'chi', Df)</VERB> génère des nombres aléatoires suivant la loi du chi 2
     à <VERB>Df</VERB> (réel &gt; 0.0) degrés de liberté. 
     Fonction(s) associée(s) : <LINK>cdfchi</LINK>.</SP>
  </ITEM>

  <ITEM label='chi 2 non centrée'>
<SP>   : <VERB>Y=grand(m,n,'nch',Df,Xnon)</VERB> génère des nombres aléatoires suivant la loi du chi 2
     non centrée à <VERB>Df</VERB> degrés de liberté (réel &gt;= 1.0) 
     le paramètre de décentrage étant <VERB>Xnonc</VERB> (réel &gt;= 0.0).
     Fonction(s) associée(s) : <LINK>cdfchn</LINK>.</SP>
  </ITEM>

  <ITEM label='exponentielle'>
<SP>   : <VERB>Y=grand(m,n,'exp',Av)</VERB> génère des nombres aléatoires suivant la loi exponentielle
     de moyenne <VERB>Av</VERB> (réel &gt;= 0.0).</SP>
  </ITEM>

  <ITEM label='F variance ratio'>
<SP>   : <VERB>Y=grand(m,n,'f',Dfn,Dfd)</VERB> génère des nombres aléatoires suivant la loi F 
     (variance ratio) à <VERB>Dfn</VERB> (réel &gt; 0.0) degrés de liberté au numérateur et
     <VERB>Dfd</VERB> (réel &gt; 0.0) degrés de liberté au dénominateur.
     Fonction(s) associée(s) : <LINK>cdff</LINK>.</SP>
  </ITEM>

  <ITEM label='non central F variance ratio'>
<SP>   : <VERB>Y=grand(m,n,'nf',Dfn,Dfd,Xnon)</VERB> génère des nombres aléatoires suivant la loi 
     F (variance ratio) non centrée à <VERB>Dfn</VERB> (réel &gt;= 1) degrés de liberté 
     au numérateur, et <VERB>Dfd</VERB> (réel &gt; 0) degrés de liberté au dénominateur, 
     <VERB>Xnonc</VERB> (réel &gt;= 0) étant le paramètre de décentrage. 
     Fonction(s) associée(s) : <LINK>cdffnc</LINK>.  </SP>
</ITEM>

  <ITEM label='gamma'>
<SP>   : <VERB>Y=grand(m,n,'gam',shape,scale)</VERB> génère des nombres aléatoires suivant la loi
     gamma de paramètres <VERB>shape</VERB> (réel &gt; 0) et <VERB>scale</VERB> 
      (réel &gt; 0). La densité est :</SP>
     <VERBATIM><![CDATA[
               shape  (shape-1)   -scale x
          scale       x          e          /  gamma(shape)
     ]]></VERBATIM>
     <SP>Fonction(s) associée(s) : <LINK>gamma</LINK>, <LINK>cdfgam</LINK>.</SP>
  </ITEM>
 
  <ITEM label='Gauss Laplace (normale)'>
<SP>   : <VERB>Y=grand(m,n,'nor',Av,Sd)</VERB> génère des nombres aléatoires suivant la loi normale 
     de moyenne <VERB>Av</VERB> (réel) et d'écart type <VERB>Sd</VERB>
     (réel &gt;= 0).
     Fonction(s) associée(s) : <LINK>cdfnor</LINK>, <LINK>erf</LINK>.</SP>
  </ITEM>

  <ITEM label='multi normale'>
<SP>   : <VERB>Y=grand(n,'mn',Mean,Cov)</VERB> génère <VERB>n</VERB> réalisations indépendantes de la
     loi multi-normale ; <VERB>Mean</VERB> doit être un vecteur <VERB>m x 1</VERB> et <VERB>Cov</VERB> 
     une matrice <VERB>m x m</VERB> symétrique et définie positive, (<VERB>Y</VERB> est alors une
     matrice <VERB>m x n</VERB>).</SP>
  </ITEM>

  <ITEM label='geometrique'>
<SP>   : <VERB>Y=grand(m,n,'geom', p)</VERB> génère des nombres aléatoires suivant la loi geométrique
     de paramètre <VERB>p</VERB> : nombre d'épreuves de Bernouilli (de probabilité de succès 
     <VERB>p</VERB>) jusqu'à obtenir un succès (<VERB>p</VERB> doit appartenir
     à l'intervalle <VERB>[pmin,1]</VERB> (avec <VERB>pmin = 1.3
	    10^(-307)</VERB>).</SP>
  </ITEM>

  <ITEM label='markov'>
<SP>   : <VERB>Y=grand(n,'markov',P,x0)</VERB> génère <VERB>n</VERB> états successifs d'une chaîne de 
     Markov décrite par la matrice de transition <VERB>P</VERB>. L'état initial est donné par 
     <VERB>x0</VERB>. Si <VERB>x0</VERB> est une matrice de taille 
     <VERB>m=size(x0,&apos;*&apos;)</VERB> 
     alors <VERB>Y</VERB> est une matrice de taille <VERB>m x n</VERB>. <VERB>Y(i,:)</VERB> étant le
     chemin à partir de l'état initial <VERB>x0(i)</VERB>.</SP>
  </ITEM>

  <ITEM label='multinomiale'>
<SP>   : <VERB>Y=grand(n,'mul',nb,P)</VERB> génère <VERB>n</VERB> réalisations indépendantes de la loi
      Multinomiale :  classer <VERB>nb</VERB> éventualités dans <VERB>m</VERB> catégories (mettre
     <VERB>nb</VERB> &quot;boules&quot; dans <VERB>m</VERB> &quot;boites&quot;). <VERB>P(i)</VERB> 
     étant la probabilité qu'une éventualité soit de categorie i. <VERB>P</VERB> le vecteur des
     probabilités est de taille <VERB>m-1</VERB> (la probabilté de la catégorie <VERB>m</VERB> 
     étant <VERB>1-sum(P)</VERB>). <VERB>Y</VERB> est alors de dimensions <VERB>m x n</VERB>, 
     chaque colonne <VERB>Y(:,j)</VERB> étant une réalisation de cette loi : <VERB>Y(i,j)</VERB> 
     est le nombre d'éventualités classées en catégorie <VERB>i</VERB> pour la <VERB>j</VERB> ème
     réalisation (<VERB>sum(Y(:,j)) = nb</VERB>).</SP>
  </ITEM>

  <ITEM label='Poisson'>
<SP>   : <VERB>Y=grand(m,n,'poi',mu)</VERB> génère des nombres aléatoires suivant la loi de Poisson 
     de moyenne <VERB>mu (réel &gt;= 0.0)</VERB>.</SP>
  </ITEM>

  <ITEM label='permutations aléatoires'>
<SP>   : <VERB>Y=grand(n,'prm',vect)</VERB> génère <VERB>n</VERB> permutations aléatoire du
     vecteur colonne (<VERB>m x 1</VERB>) <VERB>vect</VERB>.</SP>
  </ITEM>

  <ITEM label='uniforme (def)'>
<SP>   : <VERB>Y=grand(m,n,'def')</VERB> génère des nombres aléatoires suivant la loi uniforme 
     sur <VERB>[0,1[</VERB> (1 n'est jamais retourné).</SP>
  </ITEM>

  <ITEM label='uniforme (unf)'>
<SP>   : <VERB>Y=grand(m,n,'unf',Low,High)</VERB> génère des nombres aléatoires suivant la loi 
   uniforme sur <VERB>[Low, High[</VERB>.</SP>
  </ITEM>


  <ITEM label='uniforme (uin)'>
<SP>   : <VERB>Y=grand(m,n,'uin',Low,High)</VERB> génère des entiers aléatoires suivant la loi uniforme
     sur <VERB>[Low, High]</VERB>. <VERB>High</VERB>
     et <VERB>Low</VERB> doivent être des entiers tels que <VERB>(High-Low+1)
	    &lt; 2147483561</VERB>.</SP>
  </ITEM>

  <ITEM label='uniforme (lgi)'>
   <SP> : <VERB>Y=grand(m,n,'lgi')</VERB> retourne la sortie du générateur de base courant : des entiers
     aléatoires suivant une loi uniforme sur :</SP>
     <ITEMIZE>
       <ITEM> <SP><VERB>[0, 2^32 - 1]</VERB> for mt, kiss and fsultra</SP> </ITEM>
       <ITEM> <SP><VERB>[0, 2147483561]</VERB> for clcg2</SP></ITEM>
       <ITEM> <SP><VERB>[0, 2^31 - 2]</VERB> for clcg4 </SP></ITEM>
       <ITEM> <SP><VERB>[0, 2^31 - 1]</VERB> for urand.</SP></ITEM>
     </ITEMIZE>
  </ITEM>

  </ITEMIZE>
  </SECTION>
  
  <SECTION  label='Actions sur le(s) générateur(s) de base'>
  <P> Depuis Scilab-2.7 vous avez la possibilité de choisir parmi plusieurs générateurs de base
      (donnant des entiers aléatoires suivant la loi 'lgi') :
  </P>
      <ITEMIZE>
      <ITEM label='mt'> 
<SP>       : le Mersenne-Twister de M. Matsumoto and T. Nishimura, période d'environ <VERB>2^19937</VERB>, 
         état interne donné par <VERB>624</VERB> entiers (plus un index); c'est le générateur  
         par défaut.</SP>
      </ITEM>

      <ITEM label='kiss'> 
<SP>       : Le Keep It Simple Stupid de G. Marsaglia,  période d'environ <VERB>2^123</VERB>,
         état interne donné par <VERB>4</VERB> entiers.</SP>
      </ITEM>

      <ITEM label='clcg2'> 
<SP>       : une combinaison de 2 générateurs linéaires congruentiels de P. L'Ecuyer,
         période d'environ <VERB>2^61</VERB>, état interne donné par <VERB>2</VERB> entiers ; 
         c'était le seul générateur de base utilisé auparavent par grand (cette
         version est cependant légèrement différente de l'ancienne).</SP>
      </ITEM>

      <ITEM label='clcg4'> 
<SP>       : une combinaison de 4 générateurs linéaires congruentiels de P. L'Ecuyer,
         période d'environ <VERB>2^121</VERB>, état interne donné par 4 entiers ; ce générateur
         peut être partagé en <VERB>101</VERB> générateur virtuels (en fait la suite de 
         longueur <VERB>2^121</VERB> peut être découpée en <VERB>101</VERB> sous-suites) ce qui peut
         être utile dans certains cas (voir 'Actions specifiques à clcg4' et
         'Exemple d'utilisation de clcg4').</SP>
      </ITEM>

      <ITEM label='urand'> 
<SP>       : le générateur de base (congruentiel affine...) utilisé par la fonction 
         <LINK>rand</LINK>, état interne constitué d'un seul entier, période de 
         <VERB>2^31</VERB> (basé sur le vol 2 du Art of Computer Science de Knuth).
         C'est le plus rapide de cette liste mais il est maintenant dépassé : il est
         préférable de ne pas l'utiliser pour une simulation sérieuse consommant
         beaucoup de nombres aléatoires (en particulier ce générateur ne passe 
         pas certains tests statistiques classiques).</SP>
      </ITEM>

      <ITEM label='fsultra'> 
<SP>       : un générateur SWB (subtract-with-borrow) mixé avec un générator congruentiel 
             concu par Arif Zaman et George Marsaglia. Sa période est supérieure à <VERB>10^356</VERB>,
             et son état interne est constitué d'un tableau de 37 entiers, d'un index sur
             ce tableau et d'un drapeau (0 ou 1) ainsi qu'un autre entier donnant l'état interne
             du générateur congruentiel.</SP>
      </ITEM>
      </ITEMIZE>
 </SECTION>
 <SECTION label="Actions">
  <ITEMIZE>
  <ITEM label='action= &apos;getgen&apos;'>
<SP>   : <VERB>S=grand('getgen')</VERB> retourne le nom du générateur de base actuel (<VERB>S</VERB> est
     l'une des chaînes de caractères 'mt', 'kiss', 'clcg2', 'clcg4', 'urand',
	  'fsultra').</SP>
  </ITEM>

  <ITEM label='action= &apos;setgen&apos;'>
<SP>   : <VERB>grand('setgen',gen)</VERB> permet de changer le générateur de base : <VERB>gen</VERB>
     doit être l'une des chaînes de caractères 'mt', 'kiss', 'clcg2', 'clcg4', 'urand', 'fsultra'.
     En cas de succès la fonction retourne cette même chaîne.</SP>
  </ITEM>

  <ITEM label='action= &apos;getsd&apos;'>
<SP>   : <VERB>S=grand('getsd')</VERB> retourne l'état interne actuel (les 'germes' dans l'ancienne 
     appelation quoique ce terme désigne plutôt l'état initial) du générateur de base courant ;
     <VERB>S</VERB> est un vecteur colonne (d'entiers) de dimension <VERB>625</VERB> 
     pour mt (la première composante étant un 'index' sur l'état, c-a-d un entier de l'intervalle
      <VERB>[1,624]</VERB>), <VERB>4</VERB> 
     pour kiss, <VERB>2</VERB> pour clcg2 , <VERB>40</VERB>pour fsultra, <VERB>4</VERB> pour clcg4 
     (pour ce dernier vous obtenez l'état interne du générateur virtuel courant), et <VERB>1</VERB> 
     pour urand.</SP>
  </ITEM>

  <ITEM label='action= &apos;setsd&apos;'>
<SP>   : <VERB>grand('setsd',S), grand('setsd',s1[,s2,s3,s4])</VERB> impose l'état interne du générateur de
     base courant : </SP>
     <ITEMIZE>
     <ITEM label='pour mt'>
       <SP><VERB>S</VERB> est un vecteur d'entiers de dimension <VERB>625</VERB> (la première composante
       étant un index sur <VERB>[1,624]</VERB>), les <VERB>624</VERB> dernières composantes doivent 
       être dans <VERB>[0,2^32[</VERB>) (mais ne doivent pas être toutes nulles) ; une initialisation
       plus simple est possible (et recommandée) en donnant un seul entier <VERB>s1</VERB> (<VERB>s1</VERB> appartenant
       à <VERB>[0,2^32[</VERB>) ;</SP>
     </ITEM>
     <ITEM label='pour kiss'>
     <SP><VERB>4</VERB> entiers <VERB>s1,s2, s3,s4</VERB> dans <VERB>[0,2^32[</VERB> doivent être
       fournis ;</SP>
     </ITEM>
     <ITEM label='pour clcg2'>
       <SP><VERB>2</VERB> entiers <VERB>s1</VERB> dans <VERB>[1,2147483562]</VERB> et <VERB>s2</VERB> 
       dans <VERB>[1,2147483398]</VERB> doivent être fournis ;</SP>
     </ITEM>
     <ITEM label='pour clcg4'>
<SP>       <VERB>4</VERB> entiers <VERB>s1</VERB> dans <VERB>[1,2147483646]</VERB>, <VERB>s2</VERB> 
       dans <VERB>[1,2147483542]</VERB>, <VERB>s3</VERB> dans <VERB>[1,2147483422]</VERB>, 
       <VERB>s4</VERB> dans <VERB>[1,2147483322]</VERB> sont requis ;
       <VERB>ATTENTION</VERB> : avec clcg4 vous positionnez l'état interne du générateur virtuel
       courant mais vous perdez alors la synchronisation avec les autres générateurs virtuels.
       (=> si vous utilisez clcg4 avec différents générateurs virtuels, il faut utiliser
       l'option 'setall' qui permet de changer l'état interne (du générateur numéro 0) tout en
       recalculant l'état initial des 100 autres générateurs virtuels).</SP>
     </ITEM>
     <ITEM label='pour urand'>
<SP>       <VERB>1</VERB> entier <VERB>s1</VERB> appartenant à
	      <VERB>[0,2^31</VERB>[ est requis.</SP>
     </ITEM>
     <ITEM label='for fsultra'>
            <SP>:  <VERB>S</VERB> est un vecteur de <VERB>40</VERB> entiers (son premier élément doit être dans
       l'intervalle<VERB>[0,37]</VERB>, son deuxième (drapeau) doit être 0 ou 1, le troisième un
       entier de [1,2^32[ et les 37 composantes suivantes, des entiers de [0,2^32[) ; il est recommandé
       d'utiliser l'autre procédure d'initialisation (plus simple) avec deux entiers <VERB>s1</VERB> et 
       <VERB>s2</VERB> de <VERB>[0,2^32[</VERB>.</SP>
     </ITEM>
     </ITEMIZE>
  </ITEM>
  <ITEM label='action= &apos;phr2sd&apos;'>
<SP>   : <VERB>Sd=grand('phr2sd', phrase)</VERB> étant donnée une chaîne de caractères <VERB>phrase</VERB>
     cet appel retourne un vecteur <VERB>1 x 2</VERB> qui peut être utilisé comme
     état interne pour un générateur de base (initialement adapté pour clcg2).</SP>
  </ITEM>
  </ITEMIZE>
  </SECTION>

  <SECTION label='Options specifiques à clcg4'>
  <P>
    Le générateur clcg4 peut être utilisé comme les autres mais il offre l'avantage de pouvoir être
    découpé en (<VERB>101</VERB>) générateurs virtuels différents, c-a-d avec des séquences sans
    intersection (quand vous utilisez un générateur classique vous pouvez changer l'état initial
    de façon à obtenir une autre séquence mais vous n'êtes pas complètement sûr d'obtenir une
    séquence complètement différente). Chaque générateur virtuel correspond à une séquence de 
    longueur <VERB>2^72</VERB> qui est de plus découpée en <VERB>V=2^31</VERB> segments de longueur
    <VERB>W=2^41</VERB>. Pour un générateur virtuel donné vous pouvez retourner au début de la séquence
    ou au début du segment ou bien au début du segment suivant. 
    Vous pouvez aussi changer l'état initial du générateur <VERB>0</VERB> avec l'option 
    'setall' qui recalcule l'état initial des autres générateurs virtuels de sorte à obtenir 
    la synchronisation entre les générateurs (c-a-d qu'en fonction du nouvel état initial du générateur
    <VERB>0</VERB> l'état initial des générateurs <VERB>1..100</VERB> sont recalculés de façon à
    obtenir <VERB>101</VERB> séquences qui ne s'intersectent pas).
  </P>
 <ITEMIZE>
  <ITEM label='action= &apos;setcgn&apos;'>
<SP>   : <VERB>grand('setcgn',G)</VERB> sélectionne le générateur virtuel numéro <VERB>G</VERB> :
     lorsque le générateur de base courant est clcg4, c'est le générateur virtuel <VERB>G</VERB>
     qui sera alors utilisé ; les <VERB>101</VERB> générateurs virtuels sont numérotés 
     <VERB>0,1,..,100</VERB> (ainsi <VERB>G</VERB> doit être un entier de l'intervalle
     <VERB>[0,100]</VERB>) ; par défaut le générateur virtuel courant est celui de numéro
     <VERB>0</VERB>.</SP>
  </ITEM>

  <ITEM label='action= &apos;getcgn&apos;'>
<SP>   : <VERB>S=grand('getcgn')</VERB> retourne le numéro du générateur
	  virtuel courant.</SP>
  </ITEM>

  <ITEM label='action= &apos;initgn&apos;'>
   <SP> : <VERB>grand('initgn',I)</VERB> réinitialise l'état du générateur virtuel courant :</SP>
     <ITEMIZE>
     <ITEM label='I = -1'>
      <SP> : remet l'état à sa valeur initiale</SP>
     </ITEM> 
     <ITEM label='I = 0'>
      <SP> : remet l'état au début du segment courant</SP>
     </ITEM>
     <ITEM label='I = 1'>
      <SP> : positionne l'état au début du segment suivant et met à jour les valeurs définissant
        le segment courant (vous ne pouvez pas revenir au début du segment précédent).</SP>
     </ITEM>
     </ITEMIZE>
  </ITEM>

  <ITEM label='action= &apos;setall&apos;'>
<SP>   : <VERB>grand('setall',s1,s2,s3,s4)</VERB> impose l'état interne du générateur virtuel
     de numéro <VERB>0</VERB> à <VERB>s1,s2,s3,s4</VERB>. L'état initial des autres générateurs est
     alors reconstruit (de façon à obtenir 101 séquences qui ne s'intersectent pas). Voir 
     l'action 'setsd' pour les contraintes sur <VERB>s1, s2, s3, s4</VERB>.</SP>
  </ITEM>

  <ITEM label='action= &apos;advnst&apos;'>
<SP>   : <VERB>grand('advnst',K)</VERB> avance l'état du générateur virtuel courant de <VERB>2^K</VERB> 
     valeurs et réinitialise l'état initial (du générateur virtuel courant) à
	ce nouvel état.</SP>
  </ITEM>
  </ITEMIZE>
</SECTION>
  <SECTION label='Exemple d&apos;utilisation de clcg4'>
  <P>
    On cherche à comparer deux techniques statistiques sur des données de tailles différentes.
    La première, utilisant le 'bootstrapping' est supposée a priori aussi précise que
    la deuxième technique (utilisant uniquement la force brute) tout en utilisant moins 
    de données. Pour la première méthode, un ensemble de données de taille n1, uniformément
    distribuée entre 25 et 50 devra être généré puis analysé par la méthode.  Pour la
    seconde méthode, on procède de même avec une taille n2 à choisir entre 100 et 200. Ce processus
    est répété 1000 fois. Pour la réduction de la variance, on veut que les nombres aléatoires
    utilisés dans les deux méthodes soient les mêmes pour chacune des 1000 comparaisons.
    Comme la deuxième méthode utilise plus de nombres aléatoires, la synchronisation
    peut être difficile si l'on utilise un générateur classique. Avec un générateur 
    comme clcg4 c'est par contre très simple : utilisez le générateur 0 pour obtenir
    la taille n1 du jeux de données et le générateur 1 pour obtenir les données.
    Avec le générateur 0 tirer la taille n2 puis resélectionner le générateur 1 et revenez
    au début du segment courant pour obtenir les n2 données pour la deuxième méthode : ainsi
    les données initiales (les n1 premieres) sont les mêmes pour les deux méthodes.
    Pour la comparaison suivante, il suffit d'avancer le générateur 1 au segment suivant,
    etc, etc.
  </P>
  </SECTION>
  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>rand</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>

  <AUTHORS>
  <AUTHORS_ITEM label='randlib'>
     <SP> Les codes qui permettent de générer les lois autres que def, unf, lgi,  uin et geom 
     proviennent de &quot;Library of Fortran Routines for Random Number  Generation&quot;, 
     de Barry W. Brown et James Lovato, Department of Biomathematics, The University of 
     Texas, Houston.</SP>  
  </AUTHORS_ITEM>
  <AUTHORS_ITEM label='mt'>
     <SP> Le code est le mt19937int.c par M. Matsumoto and  T. Nishimura, &quot;Mersenne Twister: 
     A 623-dimensionally equidistributed  uniform pseudorandom number generator&quot;, 
     ACM Trans. on Modeling and  Computer Simulation Vol. 8, No. 1, January, pp.3-30 1998.</SP> 
  </AUTHORS_ITEM>
  <AUTHORS_ITEM label='kiss'>
     <SP> Ce code a été donné par G. Marsaglia lors d'une discussion concernant la génération
     de nombres aléatoires en langage C dans plusieurs forums usenet (dont sci.math.num-analysis) 
     &quot;My offer of  RNG&apos;s for C was an invitation to dance...&quot; seul kiss a été
     inclus dans Scilab (kiss est construit à partir de plusieurs générateurs mais qui ne
     sont accessibles à l'interpréteur scilab).</SP> 
  </AUTHORS_ITEM>
  <AUTHORS_ITEM label='clcg2'>
     <SP> Cette méthode est de P. L&apos;Ecuyer mais le code C code provient de la page
     personnelle de Luc  Devroye (http://cgm.cs.mcgill.ca/~luc/rng.html).</SP> 
  </AUTHORS_ITEM>
  <AUTHORS_ITEM label='clcg4'>
     <SP> Ce code est de P. L&apos;Ecuyer et Terry H.Andres et est distribué avec un article
     à partir de la page personnelle de P. L&apos;Ecuyer 
     ( http://www.iro.umontreal.ca/~lecuyer/papers.html). Ce paquetage est le successeur 
     logique d'un plus ancien utilisant le générateur clcg2 (muni d'un mécanisme équivalent
     de générateurs virtuels) : P.  L&apos;Ecuyer and S. Cote. Implementing a Random   
     Number Package with Splitting Facilities.  ACM Transactions on Mathematical Software 
     17:1,pp 98-111.</SP> 
  </AUTHORS_ITEM>
  <AUTHORS_ITEM label='fsultra'>
     <SP> un code d' Arif Zaman (arif@stat.fsu.edu) et de George Marsaglia (geo@stat.fsu.edu)</SP> 
  </AUTHORS_ITEM>
  <AUTHORS_ITEM label='scilab packaging'>
     <SP> Par Jean-Philippe Chancelier et Bruno Pinçon  </SP> 
  </AUTHORS_ITEM>
  </AUTHORS>

</MAN>
