/* Generated by GIWS (version 2.0.2) with command:
giws --disable-return-size-array --output-dir src\jni --throws-exception-on-error --description-file src\jni\builder.giws.xml
*/
/*

This is generated code.

This software is a computer program whose purpose is to hide the complexity
of accessing Java objects/methods from C++ code.

Copyright (C) 2012 - 2016 - Scilab Enterprises

This file is hereby licensed under the terms of the GNU GPL v2.0,
pursuant to article 5.3.4 of the CeCILL v.2.1.
This file was originally licensed under the terms of the CeCILL v2.1,
and continues to be available under such terms.
For more information, see the COPYING file which you should have received
along with this program.
*/


#ifndef __ORG_SCILAB_MODULES_GRAPHIC_OBJECTS_BUILDER_BUILDER__
#define __ORG_SCILAB_MODULES_GRAPHIC_OBJECTS_BUILDER_BUILDER__
#include <iostream>
#include <string>
#include <string.h>
#include <stdlib.h>
#include <jni.h>

#include "GiwsException.hxx"

        #if defined(_MSC_VER) /* Defined anyway with Visual */
            #include <Windows.h>
        #else
            typedef signed char byte;
        #endif


#ifndef GIWSEXPORT
# if defined(_MSC_VER) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define GIWSEXPORT
#   else
#     define GIWSEXPORT __declspec(dllexport)
#   endif
# else
#   if __GNUC__ >= 4
#     define GIWSEXPORT __attribute__ ((visibility ("default")))
#   else
#     define GIWSEXPORT
#   endif
# endif
#endif

namespace org_scilab_modules_graphic_objects_builder {
class GIWSEXPORT Builder {

private:
JavaVM * jvm;

protected:
jmethodID jintcreateRectjintintjdoubledoublejdoubledoublejdoubledoublejdoubledoublejintintjintintjintintjintintID; // cache method id
jmethodID jintcloneGraphicContextjintintjintintID; // cache method id
jmethodID jintcloneFontContextjintintjintintID; // cache method id
jmethodID jintcreateHiddenLabeljintintID; // cache method id
jmethodID jbooleanisAxesRedrawingjintintID; // cache method id
jmethodID jintcreateLabeljintintjintintID; // cache method id
jmethodID jintcreateNewFigureWithAxesID; // cache method id
jmethodID jintcreateFigurejbooleanbooleanjintintjintintjbooleanbooleanjbooleanbooleanID; // cache method id
jmethodID voidcloneMenusjintintjintintID; // cache method id
jmethodID jintcloneAxesModeljintintID; // cache method id
jmethodID jintcreateSubWinjintintID; // cache method id
jmethodID jintcreateTextjintintjobjectArray_java_lang_Stringjava_lang_StringjintintjintintjdoubledoublejdoubledoublejbooleanbooleanjdoubleArray_doubledoublejintintjintintjbooleanbooleanjintintjbooleanbooleanjbooleanbooleanjbooleanbooleanjbooleanbooleanjintintID; // cache method id
jclass stringArrayClass;
jmethodID jintcreateArcjintintjdoubledoublejdoubledoublejdoubledoublejdoubledoublejdoubledoublejdoubledoublejintintjbooleanbooleanjintintjbooleanbooleanjbooleanbooleanjbooleanbooleanID; // cache method id
jmethodID jintcreateAxisjintintjintintjintintjdoubleArray_doubledoublejdoubleArray_doubledoublejintintjstringjava_lang_StringjintintjintintjintintjbooleanbooleanID; // cache method id
jmethodID jintcreateCompoundjintintjintArray_intintID; // cache method id
jmethodID jintcreateCompoundSeqjintintjintintID; // cache method id
jmethodID jintcreateFecjintintjdoubleArray_doubledoublejintArray_intintjintArray_intintjbooleanbooleanID; // cache method id
jmethodID jintcreateGrayplotjintintjintintjdoubleArray_doubledoublejintintjintintID; // cache method id
jmethodID jintcreatePolylinejintintjbooleanbooleanjintintjintintjbooleanbooleanjintArray_intintjintintjbooleanbooleanjintintjbooleanbooleanjintintjbooleanbooleanjbooleanbooleanjbooleanbooleanjbooleanbooleanjbooleanbooleanID; // cache method id
jmethodID jintcreateLegendjintintjobjectArray_java_lang_Stringjava_lang_StringjintArray_intintID; // cache method id
jmethodID jintcreateSegsjintintjdoubleArray_doubledoublejdoubleArray_doubledoublejdoubleArray_doubledoublejbooleanbooleanjintArray_intintjdoubledoubleID; // cache method id
jmethodID jintcreateChampjintintjdoubleArray_doubledoublejdoubleArray_doubledoublejdoubleArray_doubledoublejdoubleArray_doubledoublejdoubledoublejbooleanbooleanID; // cache method id
jmethodID jintcreateSurfacejintintjintintjintintjintintID; // cache method id
jmethodID voidinitSubWinTo3djintintjstringjava_lang_StringjbooleanbooleanjintArray_intintjdoubledoublejdoubledoublejdoubleArray_doubledoublejdoubleArray_doubledoublejdoubleArray_doubledoublejdoubleArray_doubledoubleID; // cache method id
jmethodID jintcreateLightjintintjintintjbooleanbooleanjdoubleArray_doubledoublejdoubleArray_doubledoublejdoubleArray_doubledoublejdoubleArray_doubledoublejdoubleArray_doubledoubleID; // cache method id



jobject instance;
jclass instanceClass; // cache class

                       
// Caching (if any)


/**
* Get the environment matching to the current thread.
*/
virtual JNIEnv * getCurrentEnv();

public:
// Constructor
/**
* Create a wrapping of the object from a JNIEnv.
* It will call the default constructor
* @param JEnv_ the Java Env
*/
Builder(JavaVM * jvm_);

/**
* Create a wrapping of an already existing object from a JNIEnv.
* The object must have already been instantiated
* @param JEnv_ the Java Env
* @param JObj the object
*/
Builder(JavaVM * jvm_, jobject JObj);


/** 
* This is a fake constructor to avoid the constructor
* chaining when dealing with extended giws classes 
*/
#ifdef FAKEGIWSDATATYPE
Builder(fakeGiwsDataType::fakeGiwsDataType /* unused */) {}
#endif

// Destructor
~Builder();

// Generic method
// Synchronization methods
/**
* Enter monitor associated with the object.
* Equivalent of creating a "synchronized(obj)" scope in Java.
*/
void synchronize();

/**
* Exit monitor associated with the object.
* Equivalent of ending a "synchronized(obj)" scope.
*/
void endSynchronize();

// Methods
static int createRect(JavaVM * jvm_, int pparentsubwinUID, double x, double y, double height, double width, int foreground, int background, int isfilled, int isline);

static int cloneGraphicContext(JavaVM * jvm_, int sourceIdentifier, int destIdentifier);

static int cloneFontContext(JavaVM * jvm_, int sourceIdentifier, int destIdentifier);

static int createHiddenLabel(JavaVM * jvm_, int parent);

static bool isAxesRedrawing(JavaVM * jvm_, int subWin);

static int createLabel(JavaVM * jvm_, int parent, int type);

static int createNewFigureWithAxes(JavaVM * jvm_);

static int createFigure(JavaVM * jvm_, bool dockable, int menubarType, int toolbarType, bool defaultAxes, bool visible);

static void cloneMenus(JavaVM * jvm_, int model, int newParent);

static int cloneAxesModel(JavaVM * jvm_, int parent);

static int createSubWin(JavaVM * jvm_, int parent);

static int createText(JavaVM * jvm_, int parent, char const* const* text, int textSize, int rows, int cols, double x, double y, bool autoSize, double const* userSize, int userSizeSize, int centerPos, int foreground, bool isForeground, int background, bool isBackground, bool boxed, bool line, bool filled, int align);

static int createArc(JavaVM * jvm_, int parent, double x, double y, double h, double w, double start, double end, int foreground, bool isForeground, int background, bool isBackground, bool filled, bool line);

static int createAxis(JavaVM * jvm_, int parent, int dir, int tics, double const* vx, int vxSize, double const* vy, int vySize, int subint, char const* format, int fontSize, int textColor, int ticsColor, bool seg);

static int createCompound(JavaVM * jvm_, int parent, int const* children, int childrenSize);

static int createCompoundSeq(JavaVM * jvm_, int parent, int childrenCount);

static int createFec(JavaVM * jvm_, int parent, double const* zminmax, int zminmaxSize, int const* colminmax, int colminmaxSize, int const* colout, int coloutSize, bool with_mesh);

static int createGrayplot(JavaVM * jvm_, int parent, int type, double const* pvecx, int pvecxSize, int n1, int n2);

static int createPolyline(JavaVM * jvm_, int parent, bool closed, int plot, int foreground, bool isForeground, int const* background, int backgroundSize, int mark_style, bool isMarkStyle, int mark_foreground, bool isMarkForeground, int mark_background, bool isMarkBackground, bool isline, bool isfilled, bool ismark, bool isinterp);

static int createLegend(JavaVM * jvm_, int parent, char const* const* text, int textSize, int const* handles, int handlesSize);

static int createSegs(JavaVM * jvm_, int parent, double const* vx, int vxSize, double const* vy, int vySize, double const* vz, int vzSize, bool isVZ, int const* style, int styleSize, double arsize);

static int createChamp(JavaVM * jvm_, int parent, double const* vx, int vxSize, double const* vy, int vySize, double const* vfx, int vfxSize, double const* vfy, int vfySize, double arsize, bool typeofchamp);

static int createSurface(JavaVM * jvm_, int parent, int typeof3d, int colorFlag, int colorMode);

static void initSubWinTo3d(JavaVM * jvm_, int parent, char const* legend, bool isLegend, int const* flag, int flagSize, double alpha, double theta, double const* ebox, int eboxSize, double const* x, int xSize, double const* y, int ySize, double const* z, int zSize);

static int createLight(JavaVM * jvm_, int parent, int type, bool visible, double const* pos, int posSize, double const* dir, int dirSize, double const* ambient, int ambientSize, double const* diffuse, int diffuseSize, double const* specular, int specularSize);


                        /**
                        * Get class name to use for static methods
                        * @return class name to use for static methods
                        */
                        
                static const std::string className()
                {
                return "org/scilab/modules/graphic_objects/builder/Builder";
                }
                

                        /**
                        * Get class to use for static methods
                        * @return class to use for static methods
                        */
                        
                static jclass initClass(JNIEnv * curEnv)
                {
                    static jclass cls = 0;

                    if (cls == 0)
                    {
                        jclass _cls = curEnv->FindClass(className().c_str());
                        if (_cls)
                        {
                            cls = static_cast<jclass>(curEnv->NewGlobalRef(_cls));
                        }
                    }

                    return cls;
                 }
                
};


}
#endif
