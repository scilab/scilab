<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<DATA flag="desc">

<FILE name='ABCD_Blocks' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='ABSBLK_f' type='LATEX'>
Le bloc Abs calcule à la sortie, la valeur absolue de l'entrée.
</FILE>

<FILE name='ABS_VALUE' type='LATEX'>
Le bloc Abs calcule à la sortie, la valeur absolue de l'entrée.
</FILE>

<FILE name='AFFICH_f' type='LATEX'>
Pendant la simulation, ce bloc affiche sur le diagramme 
la valeur lue sur son unique port d'entrée événementiel.\\
{\bf Attention :} à chaque fois que le bloc est déplacé, l'utilisateur
doit cliquer sur celui-ci pour éditer ses paramètres. La position
d'affichage est alors automatiquement ajustée.
</FILE>

<FILE name='AFFICH_m' type='LATEX'>
Pendant la simulation, ce bloc affiche sur le diagramme 
la valeur lue sur son unique port d'entrée événementiel.\\
{\bf Attention :} à chaque fois que le bloc est déplacé, l'utilisateur
doit cliquer sur celui-ci pour éditer ses paramètres. La position
d'affichage est alors automatiquement ajustée.
</FILE>

<FILE name='ANDBLK' type='LATEX'>
TODO
</FILE>

<FILE name='ANDLOG_f' type='LATEX'>
Ce bloc possédant deux entrées événementielles et une sortie régulière,
délivre +1 ou -1 sur sa sortie régulière suivant ses entrées événementielles.
\begin{enumerate}
\item[+1]: Lorsque les événements sont synchrones (même événement présent sur
           les deux ports événementiels simultanément),

\item[-1]: Lorsqu'un seul événement est présent.
 \end{enumerate}
</FILE>

<FILE name='AUTOMAT' type='LATEX'>

The automaton block provides a switching mechanism between subsystems
corresponding to control modes of an automaton.  Subsystems are
constructed in such a way that they receive the state vector as input
from the automaton block and compute the flow and jump functions. The
state variables are defined only in the automaton block and not in the
subsystems.

Suppose that a hybrid automaton consists of {\bf $M$} control
 modes. The continuous-time dynamics in mode '$i$' is defined with DAE
 ($0=F_i(\dot x, x, u)$) where $i\in \{1 \dots M\}$ and the dimension
 of $x$ is $N$ ($N\ge0$) for any $i\in \{1 \dots M\}$. Suppose that in control mode '$i$', there are
 $Z_i$ jump conditions indicating jumps toward other modes. The jump
 conditions are defined by $Jump_{ij}(\dot x,x,u)$ functions where
 $j\in \{1 \dots Z_i\}$. When a jump function becomes positive, a mode
 transition will happen. When a transition to mode '$k$' happens state
 vector $x$ is reset to $Reset_k(\dot x,x,u)$, {\it i.e.,}
 $x_l=Reset_{kl}(\dot x,x,u)$ for $l\in \{1 \dots N\}$. In
 order to develop an automaton containing a mode with multiple reset
 functions, the value of the current and previous active modes should
 be used. These values are available at the first output port of the
 block.


 For such a hybrid automaton, we can use the automaton block of
 Scicos. This block has the following input/output ports, see
 Fig.~\ref{bclk0}.

\begin{itemize}
\item {\bf Output 1:} The first output port is a vector of size two
 consisting of the current and the previous active control modes.

\item {\bf Output 2:} The second output port is a vector of size {\bf
  $2N$} providing the state vector and its first time derivative, {\it
  i.e.,} $[ x,\dot x]^t$.  

\item {\bf Inputs:} The automaton block has $M$ vector input ports
  corresponding to $M$ modes or subsystems of the automaton. The input
  port '$i$' which is the output of the $i^{th}$ subsystem of the
  automaton defines the dynamic behavior in the control mode '$i$'.
  This input port is a vector of size $2N+Z_i$, as indicated in
  (\ref{xisish}). The diagram in Fig.\ref{bclk0} shows the way
  subsystems are connected to the automaton block.
$Input_i=\left[F_i(\dot x,x,u), Reset_i(\dot x,x,u), Jump_i(\dot x,x,u) \right]^t$

\begin{itemize}
\item The first $N$ elements of the $Input_i$ are the continuous-time
dynamics.  The dynamics of the system in the control mode '$i$' is
described by a smooth index-1 DAE ({\it i.e.,} $0=F_i(\dot x,x,u,t)$).

\item The next $N$ elements of $Input_i$ are the values used to
 reset the continuous-time states when a transition \underline{to} 
 control mode '$i$' is activated.

\item The next $Z_i$ elements of $Input_i$ are the jump or
zero-crossing functions. If the $j^{th}$ zero-crossing function of
mode '$i$' crosses zero with negative to positive direction, a
transition to '$j^{th}$' destination mode happens.
\end{itemize}

\item {\bf Event Output:} This is an event output port, which is
activated whenever a mode transition happens. This event is useful
when an event is needed to activate or initialize a part of the
subsystem not included in the internal dynamics of the automaton
block.
\end{itemize}

 In the interface window, the number of control modes, the initial
control mode and the initial value of continuous-time states at the
beginning of the simulation should be given.

For more documentation on the Automaton block, the user is refered to
www.scicos.org and the paper "Modeling Hybrid Automata in Scicos",
Masoud Najafi, Ramine Nikoukhah, 2007 IEEE Multi-conference on Systems
and Control, Singapore.

</FILE>

<FILE name='About_scicos' type='LATEX'>
 \subsection{Au sujet de Scicos...}

  Scicos version 4.2 a été développé dans l'équipe-projet 'Metalau', de
  manière très proche au consortium Scilab, à l'unité de Rocquencourt de
  l'INRIA.

  Les principaux contributeurs de cette version sont :

  {\bf Designers :} \\
  \begin{itemize}
       \item {\bf Fady Nassif} (INRIA) \\
          Jeu de blocs matriciels/entiers.\\
          Comportement simulink (blocs SampleClk/Goto-from).

       \item {\bf Masoud Najafi} (INRIA) \\
          Intégration Modelica.\\
          Intégration 'Sundials' dans le simulateur.

       \item {\bf Simone Mannori} (INRIA) \\
          Conception de l'éditeur nouveau graphique.

       \item {\bf Alan Layec} (INRIA) \\
          Intégration des données matricielles typées.\\
          Coeur du générateur de code C.\\
          Documentation Html.

       \item {\bf Benoit Bayol} (Etudiant) \\
          Jeu de blocs pour l'affichage des données (nouveau graphique)

 \end{itemize}

  {\bf Guru : Serge Steer} (INRIA)

  {\bf Mentor : Ramine Nikoukhah} (INRIA)
</FILE>

<FILE name='BACKLASH' type='LATEX'>
The Backlash block implements a system in which a change in input
causes an equal change in output. However, when the input changes
direction, an initial change in input has no effect on the output.
The amount of side-to-side play in the system is referred to as the
{\em deadband or gap}.
</FILE>

<FILE name='BIGSOM_f' type='LATEX'>
Le bloc somme réalise l'addition de ses entrées.
Ce bloc peut additionner des scalaires ou des vecteurs d'entrée.
</FILE>

<FILE name='BITCLEAR' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks set the specified bit of the integer input to 0.
	  The user can specify the bit in the field:"index of bit".
	  Bit 0 is the least significant bit.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BITSET' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks set the specified bit of the integer input to 1.
	  The user can specify the bit in the field:"index of bit".
	  Bit 0 is the least significant bit.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BOUNCE' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='BOUNCEXY' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='Bache' type='LATEX'>
Ce composant représente une bache thermo-hydraulique qui consiste en
deux ports d'entrée et deux ports de sortie.  Conventionnellement, la
direction positive pour la rentrée est quand le fluide {\bf entre}
dans le port d'entree (ports noirs) et la direction positive pour les
ports de sortie est quand le fluide {\bf sort} des port de sortie
(ports blancs).  La surface de la bache, la température initiale et
l'altitude initiale du fluide peuvent être definies par l'utilisateur.
Si un port reste non-utilisé, il doit être bouché par le bloc {\bf
Bouchon}.
</FILE>

<FILE name='Branching_pal' type='LATEX'>
Dans la palette Branching, vous pouvez trouver divers blocs
pour la gestion des données véhiculées par les liens réguliers.
</FILE>

<FILE name='CANIMXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of
          the two regular input signals by drawing the second input
          as a function of the first at instants of events on the
          event input port.  When a point is drawn on screen it stays
          until the buffer length is reached. This scope is useful to
          make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CANIMXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of
          the three regular input signals by drawing the third input
          as a function of the two others at instants of events on the
          event input port. When a point is drawn on screen it stays
          until the buffer length is reached. This scope is useful to
          make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CBLOCK' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en C.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='CCS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>

    This block is an ideal current source. The current value is
    controlled through the explicit input of the block (connected to
    standard Scicos blocks). The voltage across the block is
    independent of the current value.

    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CEVENTSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the input event
          signals.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CFSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This is a floating scope block.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLINDUMMY_f' type='LATEX'>
Ce bloc peut être placé dans tous diagrammes qui contient un ou
des blocs 'zero-crossing' et qui ne dispose pas de blocs contenant
des états continus (x) temps dépendant (dep\_t=\%t).
Grâce à cela, le simulateur utilisera le solveur ode pour la détection
de surfaces des blocs 'zero-crossing'.
</FILE>

<FILE name='CLKFROM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect events ports. For more
          information on how it works please refer to the
          documentation of the FROM block by clicking on the link in
          the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKGOTO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect events ports. For more
	  information on how it works please refer to the
	  documentation of the GOTO block by clicking on the link in
	  the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKGotoTagVisibility' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used in the event case. For more information
	  on how it works please refer to the documentation of the
	  GotoTagVisibility block by clicking on the link in
	  the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKINV_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port d'entrée événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKIN_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port d'entrée événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKOUTV_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port de sortie événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKOUT_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port de sortie événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.
</FILE>

<FILE name='CLKSOMV_f' type='LATEX'>
Ce bloc est un bloc d'addition d'événement à trois entrées.
La sortie reproduit les événements de tous les ports d'entrées.
A proprement parler, CLKSOMV n'est pas un vrai bloc scicos, car
il est ignoré pendant la phase de compilation.\\
Les sorties et les entrées de ce bloc sont synchronisées.
</FILE>

<FILE name='CLKSOM_f' type='LATEX'>
Ce bloc est un bloc d'addition d'événement à trois entrées.
La sortie reproduit les événements de tous les ports d'entrées.
A proprement parler, CLKSOM\_f n'est pas un vrai bloc scicos, car
il est ignoré pendant la phase de compilation.\\
Les sorties et les entrées de ce bloc sont synchronisées.
</FILE>

<FILE name='CLKSPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='CLOCK_c' type='LATEX'>
Ce bloc est un super-bloc construit grâce au bloc
\htmladdnormallink{EVTDLY\_c}{EVTDLY_c.htm} qui 
est rebouclé sur lui-même.\\
L'unique sortie de ce bloc génère des événements
à des dates précises, qui sont déterminées par le
paramètre {\bf Period} de la boîte de dialogue.
</FILE>

<FILE name='CLOCK_f' type='LATEX'>
Ce bloc est un super-bloc construit grâce au bloc
\htmladdnormallink{EVTDLY\_f}{EVTDLY_f.htm} qui
est rebouclé sur lui-même.\\
L'unique sortie de ce bloc génère des événements
à des dates précises, qui sont déterminées par le
paramètre {\bf Period} de la boîte de dialogue.
</FILE>

<FILE name='CLR' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='CLR_f' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='CLSS' type='LATEX'>
Ce bloc réalise un système linéaire d'équations d'état en temporel continu.
\begin{eqnarray}
\dot x&=&Ax+Bu\\
  y   &=&C*x+D*u
\end{eqnarray}
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
</FILE>

<FILE name='CLSS_f' type='LATEX'>
Ce bloc réalise un système linéaire d'équations d'état en temporel continu.
\begin{eqnarray}
\dot x&=&Ax+Bu\\
  y   &=&C*x+D*u
\end{eqnarray}
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
</FILE>

<FILE name='CMAT3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  CMAT3D est un scope qui montre les valeurs en Z des matrices
          sur une grille xy.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CMATVIEW' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          CMATVIEW est un scope qui montre les valeurs des matrices
          sur une grille en couleur.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CMSCOPE' type='LATEX'>
Au début de la simulation, ce bloc ouvre une fenêtre  pour afficher
l'évolution temporelle des données qui seront lues sur les ports
d'entrées réguliers.
Ce bloc est donc similaire à un oscilloscope.
Il permet l'affichage de multiple abscisses (une par entrée).
Ces abscisses peuvent avoir des échelles temporelles différentes
qui seront définies par le paramètre {\bf Refresh period}.
</FILE>

<FILE name='CONST' type='LATEX'>
Ce bloc est un générateur de valeurs constantes.
</FILE>

<FILE name='CONSTRAINT_f' type='LATEX'>
Ce bloc définit des relations algébriques implicites.
</FILE>

<FILE name='CONST_f' type='LATEX'>
Ce bloc est un générateur de valeurs constantes.
</FILE>

<FILE name='CONST_m' type='LATEX'>
Ce bloc est un générateur de valeurs constantes.
</FILE>

<FILE name='CONVERT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block converts an input signal of any data type to a
        specified data type. The input can be real, complex or integer.
        When the output is an integer and when overflow occurs the block
        three different forms of results :
        </P>
	  <P>1- A normal non saturated result.</P>
	  <P>2- A saturated result.</P>
	  <P>3- An error message warning the user about the overflow..</P>
	<P>
        The user can select one of these three forms by setting
        the "DO ON OVERFLOW" field to 0,1 or 2.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='COSBLK_f' type='LATEX'>
$$y=\cos(u)$$
</FILE>

<FILE name='CSCOPE' type='LATEX'>
Au début de la simulation, ce bloc ouvre une fenêtre  pour afficher
l'évolution temporelle des données qui seront lues sur le port
d'entrée régulier.
Ce bloc est donc similaire à un oscilloscope.
Il permet d'afficher sur une même figure l'évolution des
éléments d'un vecteur.
Ce bloc ne possède qu'une seule échelle temporelle.
</FILE>

<FILE name='CSCOPXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the
          two regular inputs signals by drawing the second input as a
          function of the first at instants of events on the event input
          port. When a point is drawn on screen it stays until the
          simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CSCOPXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the
          three regular inputs signals by drawing the third input as a
          function of the two others at instants of events on the event
          input port. When a point is drawn on screen it stays until the
          simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CUMSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The CUMSUM block sums the element of an input m*n matrix u
          along either the rows, the columns or the first non singleton
          dimension. When the "Sum along" parameter is set to "1", the
          block sums across the elements of each row. The result will be
          displayed as a m*1 matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "2", the block sums
          across the elements of each column. The result will be display
          as a 1*n matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "0", the block sums
          across the first non singleton dimension. The result will be
          displayed as one element.
	  This block is equivalent to cumsum in scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CURVE_c' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block allows the user to create signals and use them as a signal
source block. The signals can be created either graphically by the
user or be defined by specifying two vectors, i.e., a vector for time
and a vector for amplitude. These vectors define the mesh points and
the signal value at intermediate points are obtained by interpolating
the points. Several interpolation methods are available. This block
can also generate the signal periodically. It is also possible to read
data from Excel data-sheets and from formatted C data files.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CURV_f' type='LATEX'>
Ce bloc définit une fonction tabulée en fonction du temps.
Entre chaque point des mailles, ce bloc réalise une interpolation
linéaire. En dehors des points tabulés, il fournit les derniers
points rencontrés. L'utilisateur peut définir les différents points
en utilisant un éditeur graphique de courbes.
</FILE>

<FILE name='CVS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    This block is an ideal voltage source. The voltage value is
    controlled through the explicit input of the block (connected to
    standard Scicos blocks). The current passing through  the block is
    independent of the voltage across the block terminals.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='C_macros' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='C_struct' type='LATEX'>
The C structure of a scicos block defines all the fields to handle data provided by the simulator
such inputs/outputs, parameters, states, ...

That structure of type {\tt scicos\_block} is defined in the file \htmladdnormallink{scicos\_block4.h}
{scicos_block4_h.htm}, and user must include that header in each computational functions in the form :

\begin{verbatim}
#include "scicos_block4.h"

void mycomputfunc(scicos_block *block,int flag)
{
 ...
}
\end{verbatim}

The fields, that can be either C pointers or directly data, are then accessible via the {\tt *block}
structure :

\begin{verbatim}
block->my_field
\end{verbatim}

This acces is a \textbf{direct} approach and most of users should prefer the \textbf{\htmladdnormallink{C\_macros}
{C_macros.htm}} approach for facilities purpose.

In the current version of scicos, the {\tt scicos->block} structure is defined :

\begin{verbatim}
/* scicos_block structure definition */
typedef struct {
  int nevprt;
  voidg funpt ;
  int type;
  int scsptr;
  int nz;
  double *z;
  int noz;
  int *ozsz;
  int *oztyp;
  void **ozptr;
  int nx;
  double *x;
  double *xd;
  double *res;
  int nin;
  int *insz;
  void **inptr;
  int nout;
  int *outsz;
  void **outptr;
  int nevout;
  double *evout;
  int nrpar;
  double *rpar;
  int nipar;
  int *ipar;
  int nopar;
  int *oparsz;
  int *opartyp;
  void **oparptr;
  int ng;
  double *g;
  int ztyp;
  int *jroot;
  char *label;
  void **work;
  int nmode;
  int *mode;
} scicos_block;
\end{verbatim}

\begin{itemize}
 \item {\bf nevprt :} Integer that gives the event input port number by which the block has been activated.
                      This number is a binary coding. For i.e, if block have two event inputs ports,
                      {\tt block->nevptr} can take the value 1 if the block has been called by its first
                      event input port, the value 2 if it has called by the second event input port and 3
                      if it is called by the same event on input port 1 and 2.\\
                      Note that {\tt block->nevptr} can be -1 if the block is internally called. \\
                      One can also retrieve this number by using the C macros {\tt GetNevIn(block)}.

 %\item {\bf funpt :}
 \item {\bf type :} Integer that gives the type of the computation function. For C blocks, this number
                    is equal to 4.

 %\item {\bf scsptr :}
 \item {\bf nz :} Integer that gives the length of the discrete state register.\\
                  One can't override the index {\tt block->nz-1} when reading data in the array {\tt z}
                  with a C computational function.\\
                  This value is also accessible via the C macros {\tt GetNdstate(block)}.

 \item {\bf z :} Array of double of size nz,1 corresponding to the discrete state register.\\
                 A value of a discrete state is directly readable (for i.e the second state) with
                 the C instructions :

                 {\tt
                  double z\_2;\\
                  ...\\
                  z\_2=block->z[1];
                 }

                 Note that the state register should be only written for {\tt flag}=4 and {\tt flag}=2.\\
                 The pointer of that array can also be retrieve via the C macros {\tt GetDstate(block)}.

 \item {\bf noz :} Integer that gives the number of the discrete object states.\\
                   One can't override the index {\tt block->noz-1} when accessing data in the arrays
                   {\tt ozsz}, {\tt oztyp} and {\tt ozptr} in a C computational function.\\
                   This value is also accessible via the C macro {\tt GetNoz(block)}.

 \item {\bf ozsz :} An array of integer of size noz,2 that contains the dimensions of matrices of
                    discrete object states.\\
                    The first column is for the first dimension and the second for the second dimension.
                    For i.e. if we want the dimensions of the last object state, we'll use the instructions :

                    {\tt
                     int noz;\\
                     int n,m;\\
                     ...\\
                     /*get the number of object state*/\\
                     noz=block\->noz;\\
                     ...\\
                     /*get number of row of the last object state*/\\
                     n=block\->ozsz[noz-1];\\
                     /*get number of column of the last object state*/\\
                     m=block\->ozsz[2*noz-1];\\
                    }

                    The dimensions of object discrete states can be get with the following C macro :

                    {\tt
                     GetOzSize(block,x,1); /*get first dimension of oz*/ \\
                     GetOzSize(block,x,2); /*get second dimension of oz*/ \\
                    }

                    with {\tt x} an integer that gives the index of the discrete object state, {\bf numbered
                    from 1 to noz}.

 \item {\bf oztyp :} An array of integer of size noz,1 that contains the type of matrices of
                     discrete object states.\\
                     The following table gives the correspondence table for scicos type expressed in Scilab number,
                     in C number and also corresponding C pointers and C macros used for {\tt ozptr} :

                     \begin{tabular}{|c|c|c|c|c|}
                      \hline
                      {\bf Scilab}&
                      &
                      {\bf C}&
                      &
                      \\
                      \hline
                      \hline
                      Type&
                      &
                      Number&
                      Type&
                      Macros\\
                      \hline
                      real matrix&
                      &
                      10&
                      double&
                      SCSREAL\_COP\\
                      \hline
                      complex matrix&
                      &
                      11&
                      double&
                      SCSCOMPLEX\_COP\\
                      \hline
                      int32 matrix&
                      &
                      84&
                      long int&
                      SCSINT32\_COP\\
                      \hline
                      int16 matrix&
                      &
                      82&
                      short&
                      SCSINT16\_COP\\
                      \hline
                      int8 matrix&
                      &
                      81&
                      char&
                      SCSINT8\_COP\\
                      \hline
                      uint32 matrix&
                      &
                      814&
                      unsigned long int&
                      SCSUINT32\_COP\\
                      \hline
                      uint16 matrix&
                      &
                      812&
                      unsigned short&
                      SCSUNINT16\_COP\\
                      \hline
                      uint8 matrix&
                      &
                      811&
                      unsigned char&
                      SCSUINT8\_COP\\
                      \hline
                      all others data&
                      &
                      -1&
                      double&
                      SCSUNKNOWN\_COP\\
                      \hline
                     \end{tabular}

                     The type of discrete object state can also be got by the use of the C macro
                     {\tt GetOzType(block,x)}. For i.e, if we want the C number type of the first
                     discrete object state, we'll use the following C instructions:

                     {\tt
                      int oztyp\_1;\\
                     ...\\
                      /*get the number type of the first object state*/\\
                      oztyp\_1 = GetOzType(block,1);
                     }

 \item {\bf ozptr :} An array of pointers of size noz,1 that allow to directly acces to the
                     data contained in the discrete object state.\\
                     Suppose that you have defined in the editor a block with the following 
                     \textbf{odstate} field in \htmladdnormallink{scicos\_model}{scicos_model.htm} :

                     \begin{eqnarray}
                       {\tt model.odstate}={\tt list}\left({\tt int32}\left(\left[\begin{array}{cc}
                       1 & 2\\
                       3 & 4\end{array}\right]\right),\left[\begin{array}{ccc}
                       1+{\tt \% i} & {\tt \% i} & 0.5\end{array}\right]\right)
                     \end{eqnarray}

                     Then we have two discrete object states, one is an 32-bit integer matrix with two rows and two
                     columns and the second is a vector of complex numbers that can be understand as a matrix
                     of size 1,3.\\
                     At the C computational function level, the instructions {\tt block->ozsz[0]},
                     {\tt block->ozsz[1]}, {\tt block->ozsz[2]}, {\tt block->ozsz[3]} will respectively return the
                     values 2,1,2,3 and the instructions {\tt block->oztyp[0]}, {\tt block->oztyp[1]} the values 11 and
                     84.\\
                     {\tt block->ozptr} will contain then two pointers, and should be viewed as arrays contained data of
                     discrete object state as shown in the following figure :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{oz.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     SCSINT32\_COP *ptr\_i;\\
                     SCSINT32\_COP cumsum\_i;\\
                     SCSCOMPLEX\_COP *ptr\_d;\\
                     SCSREAL\_COP cumsum\_r;
                     ...\
                     \null\\
                     /*get the ptrs of an int32 discrete object state*/\\
                     ptr\_i = (SCSINT32\_COP *) block->ozptr[0];\\
                     /*get the ptrs of a double discrete object state*/\\
                     ptr\_d = (SCSCOMPLEX\_COP *) block->ozptr[1];\\
                     ...\\
                     /*compute the cumsum of the int32 matrix*/\\
                     cumsum\_i = ptr\_i[0]+ptr\_i[1]+ptr\_i[2]+ptr\_i[3];
                     ...\\
                     /*compute the cumsum of the real part of the complex matrix*/\\
                     cumsum\_d = ptr\_d[0]+ptr\_d[1]+ptr\_d[2];\\
                     ...\\
                    }

                    One can also use the set of C macros :\\
                    {\tt GetRealOzPtrs(block,x)},  {\tt GetImagOzPtrs(block,x)},\\
                    {\tt Getint8OzPtrs(block,x)},  {\tt Getint16OzPtrs(block,x)},\\
                    {\tt Getint32OzPtrs(block,x)}, {\tt Getuint8OzPtrs(block,x)},\\
                    {\tt Getuint16OzPtrs(block,x)}, {\tt Getuint32OzPtrs(block,x)} \\
                    to have the appropiate pointer of the data to handle ({\bf x is numbered from 1 to noz}).\\
                    For the previous example that gives :

                    {\tt
                     SCSINT32\_COP *ptr\_i;\\
                     SCSREAL\_COP *ptr\_dr;\\
                     SCSREAL\_COP *ptr\_di;\\
                     ...\
                     \null\\
                     /*get the ptrs of an int32 discrete object state*/\\
                     ptr\_i = Getint32OzPtrs(block,1);\\
                     /*get the ptrs of a double discrete object state*/\\
                     ptr\_dr = GetRealOzPtrs(block,2);\\
                     ptr\_di = GetImagOzPtrs(block,2);\\
                     ...\\
                    }

                    Finally note that the discrete objects state should be only written for {\tt flag}=4 and {\tt flag}=2.


 \item {\bf nx :} Integer that gives the length of the continus state register.\\
                  One can't override the index {\tt block->nx-1} when reading or writing data in 
                  the array {\tt x}, {\tt xd} or {\tt res} with a C computational function.

 \item {\bf x :} Array of double of size nx,1 corresponding to the continuous state register.\\
                 That gives the result of the computation of the state derivative.\\
                 A value of a continuous state is readable (for i.e the first state) with
                 the C instructions :

                 {\tt
                  double x\_1;\\
                    ...\\
                  x\_1=block->x[0];
                 }

                 Note that on {\it flag}=4, user can write some initial conditions in that register.\\

 \item {\bf xd :} Array of double of size nx,1 corresponding to the derivative of the continuous state register.\\
                  When systems are explicitly given in terms of Ordinary Differential Equations (ODE), it can be
                  explicitly expressed or implicitly used in the residual vector {\tt res} when systems are expressed
                  in terms of Differantial Algebraic Equations (DAE). \\
                  Both systems must be programmed with {\tt flag= 0}.\\
                  For i.e the Lorentz attractor written as an ODE system with three state variables, of the form :

                   \begin{eqnarray}
                        \dot{x} &=& f(x,t)
                   \end{eqnarray}
                  will be defined :

                  {\tt
                   ...\\
                   double *x = block->x;\\
                   double *xd = block->xd;\\
                   ...\\
                   /* define parameters */\\
                   double a = 10;\\
                   double b = 28;\\
                   double c = 8/3;\\
                   ...\\
                   if (flag == 0) \{\\
                      xd[0] = a*(x[1]-x[0]); \\
                      xd[1] = x[1]*(b-x[2])-x[1]; \\
                      xd[2] = x[0]*x[1]-c*x[2]; \\
                   \}
                  }

 \item {\bf res :} Array of double of size nx,1 corresponding to Differential Algebraic Equation (DAE) residual.\\
                   It is used to write the vector of systems that have the following form :
                   \begin{eqnarray}
                        f(\dot{x},x,t) &=& 0
                   \end{eqnarray}
                   For i.e the Lorentz attractor written as a DAE system with three state variables, will be defined :

                   {\tt
                    ...\\
                    double *x = block->x;\\
                    double *xd = block->xd;\\
                    double *res = block->res;\\
                    ...\\
                    /* define parameters */\\
                    double a = 10;\\
                    double b = 28;\\
                    double c = 8/3;\\
                    ...\\
                    if (flag == 0) \{\\
                      res[0] =  - xd[0] + (a*(x[1]-x[0])); \\
                      res[1] =  - xd[1] + (x[0]*(b-x[2])-x[1]); \\
                      res[2] =  - xd[2] + (x[0]*x[1]-c*x[2]); \\
                    \}
                   }

 \item {\bf nin :} Integer that gives the number of regular input ports of the block.\\
                   One can't override the index {\tt (3*block->nin)-1} when reading sizes of
                   input ports in the array {\tt insz} and the index {\tt block->nin-1} when reading
                   data in the array {\tt inptr} with a C computational function.\\
                   The number of regular input ports can also be got by the use of the C macros
                   {\tt GetNin(block)}.

 \item {\bf insz :} An array of integers of size {\tt 3*nin,1} that respectively gives the first dimensions,
                    the second dimensions and the type of data driven by regular input ports.\\
                    Note that this array of size differs from the array {\tt ozsz} and {\tt oparsz} to
                    provide full compatibilty with blocks that only use a single dimension.\\
                    Suppose that you have a block with three inputs : the first is an int32 matrix of
                    size 3,2, the second a single complex number (matrix of size 1,1) and the last a real
                    matrix of size 4,1.\\
                    In the  \htmladdnormallink{scicos\_model}{scicos_model.htm} of such a block, the inputs
                    will be defined :

                    {\tt
                     model.in    = [3;1;4] \\
                     model.in2   = [2;1;1] \\
                     model.intyp = [2;1;3] \\
                    }

                    and the corresponding {\tt block->insz} field at C computational function level will be
                    coded as :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{insz.pstex_t}}
                      \end{center}
                     \end{figure}

                     Do the distinction here in the type numbers defined at the {\bf Scilab level} (2,1,3)
                     and the type numbers defined at the {\bf C level} (84,11,10). The following table gives
                     the correspondance for all Scicos type:

                     \begin{center}
                      \begin{tabular}{|c|c||c|c|}
                       \hline
                       {\bf Scilab Type}&
                       {\bf Scilab Number}&
                       {\bf C Type}&
                       {\bf C Number}\\
                       \hline
                       \hline
                       real&
                       1&
                       double&
                       10\\
                       \hline
                       complex&
                       2&
                       double&
                       11\\
                       \hline
                       int32&
                       3&
                       long&
                       84\\
                       \hline
                       int16&
                       4&
                       short&
                       82\\
                       \hline
                       int8&
                       5&
                       char&
                       81\\
                       \hline
                       uint32&
                       6&
                       unsigned long&
                       814\\
                       \hline
                       uint16&
                       7&
                       unsigned short&
                       812\\
                       \hline
                       uint8&
                       8&
                       unsigned char&
                       811\\
                       \hline
                      \end{tabular}
                     \end{center}

 \item {\bf inptr :} An array of pointers of size nin,1 that allow to directly acces to the
                     data contained in the regular input matrices.\\
                     Suppose the previous example (block with three inputs : an int32 matrix of size [3,2],
                     a complex scalar and a real matrix of size [4,1]).\\
                     {\tt block->inptr} contains three pointers, and should be viewed as arrays contained
                     the data for the int32, the real and the complex matrices :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{inptr.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n3,m3;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     \null\\
                     /*get the ptrs of the first int32 regular input port*/\\
                     ptr\_i = (SCSINT32\_COP *) block->inptr[0];\\
                     /*get the ptrs of the second complex regular input port*/\\
                     ptr\_dc = (SCSCOMPLEX\_COP *) block->inptr[1];\\
                     /*get the ptrs of the third real regular input port*/\\
                     ptr\_d = (SCSREAL\_COP *) block->inptr[2];\\
                     ...\\
                     /*get the dimension of the first int32 regular input port*/\\
                     n1=block->insz[0];\\
                     m1=block->insz[3];\\
                     ...\\
                     /*compute the cumsum of the input int32 matrix*/\\
                     for(i=0;i<n1*m1;i++) \{\\
                     \ \ cumsum\_i += ptr\_i[i]; \\
                     \}\\
                     ...\\
                    }

                    One can also use the set of C macros :\\
                    {\tt GetInPortPtrs(blk,x)}, {\tt GetRealInPortPtrs(blk,x)}, \\
                    {\tt GetImagInPortPtrs(blk,x)}, {\tt Getint8InPortPtrs(blk,x)}, \\
                    {\tt Getint16InPortPtrs(blk,x)}, {\tt Getint32InPortPtrs(blk,x)}, \\
                    {\tt Getuint8InPortPtrs(blk,x)}, {\tt Getuint16InPortPtrs(blk,x)}, \\
                    {\tt Getuint32InPortPtrs(blk,x)} \\
                    to have the appropiate pointer of the data to handle and \\
                    {\tt GetNin(blk)}, {\tt GetInPortRows(blk,x)}, \\
                    {\tt GetInPortCols(blk,x)}, {\tt GetInPortSize(blk,x,y)}, \\
                    {\tt GetInType(blk,x)}, {\tt GetSizeOfIn(blk,x)} \\
                    to handle number, dimensions and type of regular input ports.
                    ({\bf x is numbered from 1 to nin and \bf y numbered  from 1 to 2}).\\

                    For the previous example that gives :

                    {\tt
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n3,m3;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     \null\\
                     /*get the ptrs of the first int32 regular input port*/\\
                     ptr\_i = Getint32InPortPtrs(block,1);\\
                     /*get the ptrs of the second complex regular input port*/\\
                     ptr\_dc = GetRealInPortPtrs(block,2);\\
                     /*get the ptrs of the third real regular input port*/\\
                     ptr\_d = GetRealInPortPtrs(block,3);\\
                     ...\\
                     /*get the dimension of the first int32 regular input port*/\\
                     n1=GetInPortRows(block,1);\\
                     m1=GetInPortCols(block,1);\\
                     ...\\
                    }

                    Finally note that the regular input port registers are only accessible for reading.

 \item {\bf nout :} Integer that gives the number of regular output ports of the block.\\
                    One can't override the index {\tt (3*block->nout)-1} when reading sizes of
                    output ports in the array {\tt outsz} and the index {\tt block->nout-1} when reading
                    data in the array {\tt outptr} with a C computational function.\\
                    The number of regular output ports can also be got by the use of the C macros
                    {\tt GetNout(block)}.

 \item {\bf outsz :} An array of integers of size {\tt 3*nout,1} that respectively gives the first dimensions,
                     the second dimensions and the type of data driven by regular output ports.\\
                     Note that this array of size differs from the array {\tt ozsz} and {\tt oparsz} to
                     provide full compatibilty with blocks that only use a single dimension.\\
                     Suppose that you have a block with two outputs : the first is an int32 matrix of
                     size 3,2, the second a single complex number (matrix of size 1,1) and the last a real
                     matrix of size 4,1.\\
                     In the  \htmladdnormallink{scicos\_model}{scicos_model.htm} of such a block, the outputs
                     will be defined :

                     {\tt
                      model.out   = [3;1;4] \\
                      model.out2   = [2;1;1] \\
                      model.outtyp = [2;1;3] \\
                     }

                     and the corresponding {\tt block->outsz} field at C computational function level will be
                     coded as :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{outsz.pstex_t}}
                      \end{center}
                     \end{figure}

                     Do the distinction here in the type numbers defined at the {\bf Scilab level} (2,1,3)
                     and the type numbers defined at the {\bf C level} (84,11,10) and please report to the 
                     previous table to have the correspondence for all Scicos type.

 \item {\bf outptr :} An array of pointers of size nout,1 that allow to directly acces to the
                     data contained in the regular output matrices.\\
                     Suppose the previous example (block with three outputs : an int32 matrix of size [3,2],
                     a complex scalar and a real matrix of size [4,1]).\\
                     {\tt block->outptr} contains three pointers, and should be viewed as arrays contained
                     the data for the int32, the real and the complex matrices :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{outptr.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n3,m3;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     \null\\
                     /*get the ptrs of the first int32 regular output port*/\\
                     ptr\_i = (SCSINT32\_COP *) block->outptr[0];\\
                     /*get the ptrs of the second complex regular output port*/\\
                     ptr\_dc = (SCSCOMPLEX\_COP *) block->outptr[1];\\
                     /*get the ptrs of the third real regular output port*/\\
                     ptr\_d = (SCSREAL\_COP *) block->outptr[2];\\
                     ...\\
                     /*get the dimension of the first int32 regular output port*/\\
                     n1=block->outsz[0];\\
                     m1=block->outsz[3];\\
                     ...\\
                     /*compute the cumsum of the output int32 matrix*/\\
                     for(i=0;i<n1*m1;i++) \{\\
                     \ \ cumsum\_i += ptr\_i[i]; \\
                     \}\\
                     ...\\
                    }

                    One can also use the set of C macros :\\
                    {\tt GetOutPortPtrs(blk,x)}, {\tt GetRealOutPortPtrs(blk,x)}, \\
                    {\tt GetImagOutPortPtrs(blk,x)}, {\tt Getint8OutPortPtrs(blk,x)}, \\
                    {\tt Getint16OutPortPtrs(blk,x)}, {\tt Getint32OutPortPtrs(blk,x)}, \\
                    {\tt Getuint8OutPortPtrs(blk,x)}, {\tt Getuint16OutPortPtrs(blk,x)}, \\
                    {\tt Getuint32OutPortPtrs(blk,x)} \\
                    to have the appropiate pointer of the data to handle and \\
                    {\tt GetNout(blk)}, {\tt GetOutPortRows(blk,x)}, \\
                    {\tt GetOutPortCols(blk,x)}, {\tt GetOutPortSize(blk,x,y)}, \\
                    {\tt GetOutType(blk,x)}, {\tt GetSizeOfOut(blk,x)} \\
                    to handle number, dimensions and type of regular output ports.
                    ({\bf x is numbered from 1 to nout and \bf y is numbered  from 1 to 2}).

                    For the previous example that gives :

                    {\tt
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n3,m3;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     \null\\
                     /*get the ptrs of the first int32 regular output port*/\\
                     ptr\_i = GetOutPortPtrs(block,1);\\
                     /*get the ptrs of the second complex regular output port*/\\
                     ptr\_dc = GetRealOutPortPtrs(block,2);\\
                     /*get the ptrs of the third real regular output port*/\\
                     ptr\_d = GetRealOutPortPtrs(block,3);\\
                     ...\\
                     /*get the dimension of the first int32 regular output port*/\\
                     n1=GetOutPortRows(block,1);\\
                     m1=GetOutPortCols(block,1);\\
                     ...\\
                    }

                    Finally note that the regular output port registers must be only written for {\tt flag}=1.

 \item {\bf nevout :} Integer that gives the number of event output ports of the block (also called
                      the length of the output event register).\\
                      One can't override the index {\tt (block->nevout)-1} when setting value of events
                      in the output event register {\tt evout}.\\
                      The number of event output ports can also be got by the use of the C macro
                      {\tt GetNevOut(block)}.

 \item {\bf evout :} Array of double of size nevout,1 corresponding to the output event register. That register
                     is used to program date of events during the simulation.\\
                     When setting values in that array, you must understand that you give a delay relative
                     to the current time of simulator :
                     \begin{eqnarray}
                         t_{\rm event} = t_{\rm cur} + T_{\rm delay}
                     \end{eqnarray}
                     where $t_{\rm event}$ is the date of the programmed event, $t_{\rm cur}$ is the current time
                     in the simulator and $T_{\rm delay}$ the value that must be informed in the output event register.

                     For i.e, suppose that you want generate an event with the first event output port, 1ms after
                     each calls of the block, then you'll use :

                     {\tt
                      ...\\
                      \null\\
                      if (flag==3) \{ \\
                       block->evout[0]=0.001;\\
                      \}\\
                      ...\\
                     }\\

                     Note that every events generated from output event register will be asynchronous with event
                     coming from event input port (even if you set {\tt block->evout[x]=0}). \\
                     The event output register must be only written for {\tt flag}=3.

 \item {\bf nrpar :} Integer that gives the length of the real parameter register.\\
                     One can't override the index {\tt (block->nrpar)-1} when reading value of real
                     parameters in the register {\tt rpar}.\\
                     The total number of real parameters can also be got by the use of the C macro
                     {\tt GetNrpar(block)}.

 \item {\bf rpar :} Array of double of size nrpar,1 corresponding to the real parameter register. That register
                    is used to pass real parameters coming from the scilab/scicos environment to your block
                    model.\\
                    The C type of that array is {\tt double *} (or C scicos type {\tt SCSREAL\_COP *}).\\
                    Suppose that you have defined the following real parameters in the
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} of a block :

                    {\tt
                     model.rpar   = [%pi;%pi/2;%pi/4] \\
                    }

                    you can retrieve the previous data in the C computational function with :

                    {\tt
                     ...\\
                     double PI;\\
                     double PI\_2;\\
                     double PI\_4;\\
                     ...\\
                     \null\\
                     /*get the first value of the real param register*/\\
                     PI = block->rpar[0]; \\
                     /*get the second value of the real param register*/\\
                     PI\_2 = block->rpar[1]; \\
                     /*get the third value of the real param register*/\\
                     PI\_4 = block->rpar[2]; \\
                     ...\\
                    }

                    You can also use the C macro {\tt GetRparPtrs(block)} to get the pointer of the
                    real parameter register. For i.e., if we define the following
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} in an interfacing function of a
                    scicos block :

                    {\tt
                     A = [1.3 ; 4.5 ; 7.9 ; 9.8];\\
                     B = [0.1 ; 0.98];
                     model.rpar   = [A;B] \\
                    }

                    in the corresponding C computational function of that block, we'll use :

                    {\tt
                     ...\\
                     double *rpar; \\
                     double *A; \\
                     double *B; \\
                     ...\\
                     \null\\
                     /*get ptrs of the real param register*/\\
                     rpar = GetRparPtrs(block); \\
                     /*get the A ptrs array*/\\
                     A = rpar; \\
                     /*get the B ptrs array*/\\
                     B = \&rpar[4]; \\
                     /*or B = rpar + 4;*/
                     ...\\
                    }

                    Note that real parameters register is only accessible for reading.

 \item {\bf nipar :} Integer that gives the length of the integer parameter register.\\
                     One can't override the index {\tt (block->nipar)-1} when reading value of integer
                     parameters in the register {\tt ipar}.\\
                     The total number of integer parameters can also be got by the use of the C macro
                     {\tt GetNipar(block)}.

 \item {\bf ipar :} Array of int of size nipar,1 corresponding to the integer parameter register. That register
                    is used to pass integer parameters coming from the scilab/scicos environment to your block
                    model.\\
                    The C type of that array is {\tt int *} (or C scicos type {\tt SCSINT\_COP *}).\\
                    Suppose that you have defined the following integer parameters in the
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} of a block :

                    {\tt
                     model.ipar   = [(1:3)';5] \\
                    }

                    you can retrieve the previous data in the C computational function with :

                    {\tt
                     ...\\
                     int one;\\
                     int two;\\
                     int three;\\
                     int five;\
                     ...\\
                     \null\\
                     /*get the first value of the integer param register*/\\
                     one = block->ipar[0]; \\
                     /*get the second value of the integer param register*/\\
                     two = block->ipar[1]; \\
                     /*get the third value of the integer param register*/\\
                     three = block->ipar[2]; \\
                     /*get the fourth value of the integer param register*/\\
                     five = block->ipar[3]; \\
                     ...\\
                    }

                    You can also use the C macro {\tt GetIparPtrs(block)} to get the pointer of the
                    real parameter register.\\
                    Most of time in the scicos C block libraries, the integer register is used to
                    parametrize the length of real parameters. For i.e. if you define the following
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} in a block :

                    {\tt
                     // set a random size for the first real parameters \\
                     A\_sz = int(rand(10)*10); \\
                     // set a random size for the second real parameters \\
                     B\_sz = int(rand(10)*10); \\
                     // set the first real parameters \\
                     A = rand(A\_sz,1,``uniform''); \\
                     // set the second real parameters \\
                     B = rand(B\_sz,1,``normal''); \\
                     // set ipar \\
                     model.ipar = [A\_sz;B\_sz] \\
                     // set rpar (length of A\_sz+B\_sz) \\
                     model.rpar = [A;B] \\
                    }

                    the array of real parameters (parametrized by ipar) can be retrieved in the
                    correspondig C computational function with :

                    {\tt
                     ...\\
                     int A\_sz; \\
                     int B\_sz; \\
                     double *rpar; \\
                     double *A; \\
                     double *B; \\
                     double cumsum;\\
                     int i; \\
                     ...\\
                     \null\\
                     /*get ptrs of the real param register*/\\
                     rpar = GetRparPtrs(block); \\
                     /*get size of the first real param register*/\\
                     A\_sz = block->ipar[0]; \\
                     /*get size of the second real param register*/\\
                     B\_sz = block->ipar[1]; \\
                     /*get the A ptrs array*/\\
                     A = rpar; \\
                     /*get the B ptrs array*/\\
                     B = \&rpar[A\_sz]; \\
                     ...\\
                     /*compute the cumsum of the first real parameter array*/\\
                     cumsum = 0;\\
                     for(i=0;i<A\_sz;i++) \{\\
                     \ \ cumsum += A[i]; \\
                     \}\\
                     ...\\
                     /*compute the cumsum of the second real parameter array*/\\
                     cumsum = 0;\\
                     for(i=0;i<B\_sz;i++) \{\\
                     \ \ cumsum += B[i]; \\
                     \}\\
                    }

                    Note that integer parameters register is only accessible for reading.

 \item {\bf nopar :} Integer that gives the number of the object parameters.\\
                     One can't override the index {\tt block->nopar-1} when accessing data in the arrays
                     {\tt oparsz}, {\tt opartyp} and {\tt oparptr} in a C computational function.\\
                     This value is also accessible via the C macro {\tt GetNopar(block)}.

 \item {\bf oparsz :} An array of integer of size nopar,2 that contains the dimensions of matrices of
                     object parameters.\\
                     The first column is for the first dimension and the second for the second dimension.
                     For i.e. if we want the dimensions of the last object parameters, we'll use the instructions :

                    {\tt
                     int nopar;\\
                     int n,m;\\
                     ...\\
                     /*get the number of object parameter*/\\
                     nopar=block\->nopar;\\
                     ...\\
                     /*get number of row of the last object parameter*/\\
                     n=block\->oparsz[nopar-1];\\
                     /*get number of column of the last object parameter*/\\
                     m=block\->oparsz[2*nopar-1];\\
                    }

                    The dimensions of object parameters can be get with the following C macro :

                    {\tt
                     GetOparSize(block,x,1); /*get first dimension of opar*/ \\
                     GetOparSize(block,x,2); /*get second dimension of opar*/ \\
                    }

                    with {\tt x} an integer that gives the index of the object parameter, {\bf numbered
                    from 1 to nopar}.

 \item {\bf opartyp :} An array of integer of size nopar,1 that contains the type of matrices of
                     object parameters.\\
                     The following table gives the correspondence table for scicos type expressed in Scilab number,
                     in C number and also corresponding C pointers and C macros used for {\tt oparptr} :

                     \begin{tabular}{|c|c|c|c|c|}
                      \hline
                      {\bf Scilab}&
                      &
                      {\bf C}&
                      &
                      \\
                      \hline
                      \hline
                      Type&
                      &
                      Number&
                      Type&
                      Macros\\
                      \hline
                      real matrix&
                      &
                      10&
                      double&
                      SCSREAL\_COP\\
                      \hline
                      complex matrix&
                      &
                      11&
                      double&
                      SCSCOMPLEX\_COP\\
                      \hline
                      int32 matrix&
                      &
                      84&
                      long int&
                      SCSINT32\_COP\\
                      \hline
                      int16 matrix&
                      &
                      82&
                      short&
                      SCSINT16\_COP\\
                      \hline
                      int8 matrix&
                      &
                      81&
                      char&
                      SCSINT8\_COP\\
                      \hline
                      uint32 matrix&
                      &
                      814&
                      unsigned long int&
                      SCSUINT32\_COP\\
                      \hline
                      uint16 matrix&
                      &
                      812&
                      unsigned short&
                      SCSUNINT16\_COP\\
                      \hline
                      uint8 matrix&
                      &
                      811&
                      unsigned char&
                      SCSUINT8\_COP\\
                      \hline
                      all others data&
                      &
                      -1&
                      double&
                      SCSUNKNOWN\_COP\\
                      \hline
                     \end{tabular}

                     The type of object parameter can also be got by the use of the C macro
                     {\tt GetOparType(block,x)}. For i.e, if we want the C number type of the first
                     object parameter, we'll use the following C instructions:

                     {\tt
                      int opartyp\_1;\\
                     ...\\
                      /*get the number type of the first object parameter*/\\
                      opartyp\_1 = GetOparType(block,1);
                     }

 \item {\bf oparptr :} An array of pointers of size nopar,1 that allow to directly acces to the
                     data contained in the object parameter.\\
                     Suppose that you have defined in the editor a block with the following 
                     \textbf{opar} field in \htmladdnormallink{scicos\_model}{scicos_model.htm} :

                     \begin{eqnarray}
                       {\tt model.opar}={\tt list}\left({\tt int32}\left(\left[\begin{array}{cc}
                       1 & 2\\
                       3 & 4\end{array}\right]\right),\left[\begin{array}{ccc}
                       1+{\tt \% i} & {\tt \% i} & 0.5\end{array}\right]\right)
                     \end{eqnarray}

                     Then we have two object parameters, one is an 32-bit integer matrix with two rows and two
                     columns and the second is a vector of complex numbers that can be understand as a matrix
                     of size 1,3.\\
                     At the C computational function level, the instructions {\tt block->oparsz[0]},
                     {\tt block->oparsz[1]}, {\tt block->oparsz[2]}, {\tt block->oparsz[3]} will respectively return the
                     values 2,1,2,3 and the instructions {\tt block->opartyp[0]}, {\tt block->opartyp[1]} the values 11 and
                     84.\\
                     {\tt block->oparptr} will contain then two pointers, and should be viewed as arrays contained data of
                     object parameter as shown in the following figure :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{opar.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     SCSINT32\_COP *ptr\_i;\\
                     SCSINT32\_COP cumsum\_i;\\
                     SCSCOMPLEX\_COP *ptr\_d;\\
                     SCSREAL\_COP cumsum\_r;
                     ...\
                     \null\\
                     /*get the ptrs of an int32 object parameter*/\\
                     ptr\_i = (SCSINT32\_COP *) block->oparptr[0];\\
                     /*get the ptrs of a double object parameter*/\\
                     ptr\_d = (SCSCOMPLEX\_COP *) block->oparptr[1];\\
                     ...\\
                     /*compute the cumsum of the int32 matrix*/\\
                     cumsum\_i = ptr\_i[0]+ptr\_i[1]+ptr\_i[2]+ptr\_i[3];
                     ...\\
                     /*compute the cumsum of the real part of the complex matrix*/\\
                     cumsum\_d = ptr\_d[0]+ptr\_d[1]+ptr\_d[2];\\
                     ...\\
                    }

                    One can also use the set of C macros :\\
                    {\tt GetRealOparPtrs(block,x)},  {\tt GetImagOparPtrs(block,x)},\\
                    {\tt Getint8OparPtrs(block,x)},  {\tt Getint16OparPtrs(block,x)},\\
                    {\tt Getint32OparPtrs(block,x)}, {\tt Getuint8OparPtrs(block,x)},\\
                    {\tt Getuint16OparPtrs(block,x)}, {\tt Getuint32OparPtrs(block,x)} \\
                    to have the appropiate pointer of the data to handle ({\bf x is numbered from 1 to nopar}).\\
                    For the previous example that gives :

                    {\tt
                     SCSINT32\_COP *ptr\_i;\\
                     SCSREAL\_COP *ptr\_dr;\\
                     SCSREAL\_COP *ptr\_di;\\
                     ...\
                     \null\\
                     /*get the ptrs of an int32 object parameter*/\\
                     ptr\_i = Getint32OparPtrs(block,1);\\
                     /*get the ptrs of a double object parameter*/\\
                     ptr\_dr = GetRealOparPtrs(block,2);\\
                     ptr\_di = GetImagOparPtrs(block,2);\\
                     ...\\
                    }

                    Note that object parameters register is only accessible for reading.

 \item {\bf ng :}
 \item {\bf g :}
 \item {\bf ztyp :}
 \item {\bf jroot :}
 \item {\bf label :}
 \item {\bf work :}
 \item {\bf nmode :}
 \item {\bf mode :}
\end{itemize}

</FILE>

<FILE name='C_utils' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Capacitor' type='LATEX'>
Un condensateur est un composant électrique ou électronique dont
l'intérêt de base est d'avoir une capacité électrique. Son
comportement électrique idéal est:
      \[  I = C{dV\over dt}\]
où:
\begin{itemize}
\item $I$ est le courant qui traverse le composant.
\item $V$ est la tension aux bornes du composant.
\item $C$ est la capacité électrique du condensateur.
\item $\textstyle{{dV\over dt}}$ est la variation de tension avec le temps.
\end{itemize}

Le condensateur peut être utilisé pour distinguer les signaux
haute-fréquences et basse-fréquence. Cette faculté est très utile
dans la conception des filtres.
</FILE>

<FILE name='ConstantVoltage' type='LATEX'>
Ce composant est un modèle pour n'importe quel dispositif ou système
qui produit une force électromotrice constante entre ses terminaux. La
tension aux bornes de cette source est C. C est définie par
l'utilisateur. Le port noir indique la tension positive. La résistance
ohmique de ce composant est zéro.
</FILE>

<FILE name='Context' type='LATEX'>
\subsection{Introduction}
In most cases, double clicking on a Scicos block leads to the opening of a dialog box used
to set the values of block parameters. These parameters, which we refer to as GUI parameters,
are not necessarily the exact duplicate of the block parameters used in the {\em computational function}
of the block used during simulation. For example the GUI parameters of a linear system block can be
the numerator and the denominator of its transfer function, whereas the parameters used during the
simulation are the {\bf A}, {\bf B}, {\bf C} and {\bf D} matrices associated with the time domain specification of
this transfer function. It is the role of the {\em interfacing function} of the block to examine the
GUI parameters given by the user, generate error messages if needed, and convert them into simulation
parameters.

In specifying the GUI parameters, the user can enter numerical expressions in the dialog box, for example
{\tt 23} or {\tt [1,4;0,2]}, but he can also enter Scilab expressions such as: {\tt exp(.4*3)+sin(.3)} or 
{\tt ones(5,5)+diag([1:5])}. But more importantly, the user can enter expressions using Scilab
variables: {\tt A}, {\tt cos(theta)/2}. These variables, which we call {\em symbolic parameters} of the block,
must have been previously defined; in most cases this is done in a {\em context}.

Using symbolic parameters in specifying GUI parameters allows the user to easily change a system parameter
affecting multiple blocks (otherwise the GUI parameter of each block has to be individually changed). To
make an analogy with standard programming languages such as C, it would be like setting {\tt double mass=0.3;} 
and using {\tt mass} everywhere in the program instead of {\tt 0.3}. Symbolic parameters can also be used to
construct parameterized models, for example it is possible to build the model
of a fully generic linear-system-Kalman-filter system in which even the size of the blocks' states 
and input/outputs are not determined in advance and vary depending on the value of the parameters. 
Indeed, the sizes of the symbolic parameters can also be changed if it does not create inconsistencies in the diagram.  

\subsection{Diagram context}
Each Scicos diagram (the main diagram as well as the Super Blocks) has a context associated with it.
The context is a {\em Scilab script}; it can be edited interactively using the ``Diagram/Context'' menu of
the diagram. To use a symbolic parameter, say the matrix {\tt A}, to be used in defining 
the GUI parameter of a block, {\tt A}
can be defined in the context of the diagram. But all the symbolic parameters of all the blocks in a diagram
are not necessarily defined in the context of that same diagram.

\subsubsection{Scope of a context variable}
A Scilab variable defined in the context of a diagram is accessible not only to the blocks of that diagram,
but also to the contexts and the blocks of all sub-diagrams below it. For example if {\tt A} is defined in the
context of Diagram D1, and Diagram D2 is a sub-diagram of D1 (is the content of a super block of D1), then
{\tt A} is available to the context of D2 and can be used in the definition of the GUI parameters of its blocks.
The context of D2 can for example contain the following instruction: {\tt B=A+2}.

If the variable {\tt A} is redefined in the context of Dn, one of the sub-diagrams of D1, then it is the new value
that is available in the blocks of Dn, and the context and the blocks of the sub-diagrams below it. So in general, to
find the definition of a symbolic parameter used in a block, first the context of the diagram containing the
block must be examined. If the parameter is not defined there, the context of the diagram containing the
first diagram must be examined and so on until the definition of the parameter is found.  

This hierarchical treatment of parameter definition using multiple contexts as opposed to a single workspace
has many advantages. The most important advantage is that a Super Block can be placed inside a diagram
without any risk of conflict, even if symbolic parameters with similar names are used in both. Another advantage
is its natural usage in the masking operation that we shall see later.

\subsubsection{Evaluation of the context}
As previously stated, a context is nothing but a list of Scilab instructions: a Scilab script. The context
of a diagram must be evaluated (script executed) in order to compute 
the symbolic parameters that are used in the definition of the GUI parameters of its blocks. The contexts
are evaluated only when necessary, in particular when the content of a context is modified. In that case,
all the GUI parameters of all the blocks in the diagram in which the context has been modified are re-evaluated, and
so are the context and the blocks' GUI parameters of all the sub-diagrams below it. The reason for re-evaluating
the sub-diagrams below it has to do with the scope of the parameters defined in the context of the first diagram.
Indeed any change in this context can affect GUI parameters of all the blocks within sub-diagrams below this first
diagram.

When a diagram is opened, its context is also evaluated so that symbolic parameters are 
made available in the environment.
The GUI parameters of the blocks are however not re-evaluated. The reason is that it is assumed that two
evaluation of the same identical contexts leads necessary to the same values of symbolic parameters. So, since
the content of the context of the diagram has not changed since it has last been saved, the blocks GUI parameters
must be up to date. This assumption holds in most cases, but not if functions such as {\tt rand} or {\tt date} are
used in the context. Another instruction that can invalidate the assumption is the execution of an external
script, for example {\tt exec('myprog.sce')}. Clearly if the file {\tt myprog.sce} is modified, the re-evaluation
of the context can lead to different values for the symbolic parameters. Scicos attempts to identify the presence 
of such commands inside the text of the context and issues a full re-evaluation if it finds it necessary when
a diagram is opened. But this identification is not full proof and a manual ``Evaluate'' button is provided to
force a full re-evaluation if the user finds it necessary. 

The ``Evaluate'' button is particularly useful when the context contains an {\tt exec} command since Scicos
does not know if the executed file is edited. In such a case, it is up to the user to force an evaluation.

Finally it should be noted that all the variables defined in a context, except for functions, are available 
as symbolic parameters. So it is recommended that intermediate variables used in the context be cleared at
the end of the context to avoid overloading the list of symbolic parameters. 


\subsection{Masking operation}
The masking operation consists of modifying a Super Block in such a way that it resembles a regular block.
Double clicking on a masked block, opens a GUI, just as in the case of a regular block (double clicking on
a Super Block opens up the diagram contained in the Super Block). The GUI parameters of a masked block
are the symbolic parameters needed to evaluate its content. These parameters are identified automatically
when the ``Create Mask'' operation is applied to a Super Block. 

By choosing to define or not to define in the context various symbolic parameters needed in a Super Block, user
can specify the GUI parameters of the block obtained after the masking operation. This is an easy way of
constructing custom blocks. The dialog box associated with the block can also be customized using the
``Customize Mask'' operation. Finally, the mask can be removed  by the ``Remove Mask'' operation. 
</FILE>

<FILE name='Counter' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	Ce bloc, suivant la loi choisie, compte à partir d'un minimum vers un maximum ou d'un maximum vers un minimun.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CurrentSensor' type='LATEX'>
Ce bloc est inséré en série dans un circuit électrique pour mesurer le
courant qui passe à travers. Si le courant positif {\bf entre} par le
port noir, il est consideré positif. La résistance ohmique de ce
composant est zéro.
</FILE>

<FILE name='DEADBAND' type='LATEX'>
Fournit une zone où la sortie est égale à zéro.
</FILE>

<FILE name='DEBUG_SCICOS' type='LATEX'>

</FILE>

<FILE name='DELAYV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DELAY_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          Ce super-bloc compilé réalise un retard discret.
          Il est construit avec un registre à décalage et une horloge.
          La valeur du retard est donnée par la pas temporel discret multiplié
          par le nombre-1 d'état du registre.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DEMUX' type='LATEX'>
En fournissant un vecteur sur le port d'entrée régulier, ce bloc
peut séparer les éléments de l'entrée par des vecteurs sur les ports
de sortie.
L'entrée est donc définie $u=[y_1;y_2,\cdots;y_n]$, où  $y_i$ sont
numérotés dans un ordre décroissant.
Les tailles des ports d'entrée et de sortie sont déterminées par le contexte.
</FILE>

<FILE name='DEMUX_f' type='LATEX'>
Given a vector valued input this block splits inputs over vector
valued outputs. So $ u=[y_1;y_2,\cdots;y_n]$ , where  $y_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.
</FILE>

<FILE name='DERIV' type='LATEX'>
Le bloc dérivée fait l'approximation de la dérivée de son entrée en calculant:
$$\frac{\Delta u}{\Delta t}$$.
</FILE>

<FILE name='DFLIPFLOP' type='LATEX'>
The DFLIPFLOP block outputs the input state when the enable is
set and on the rising edge of the clock. The input is D the
enable is en and the clock is clk. Q and !Q are the outputs of
this block. This block is almostly used with digital number, 
the input data type is int8.\\

The truth table of this block is
\begin{tabular}{|c|c||c|c|}
\hline
en&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
0&
1\\
\hline
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DIFF_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLATCH' type='LATEX'>
This block outputs the input state when the input gate is high.
The input is D the enable is C. Q and !Q are the outputs of 
this block. This block is almostly used with digital number, 
the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
C&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline 
0&
1&
0&
1\\
\hline 
1&
0&
0&
1\\
\hline 
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DLR' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle
dans l'espace de la transformée en z.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='DLRADAPT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLR_f' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle
dans l'espace de la transformée en z.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='DLSS' type='LATEX'>
Ce bloc réalise un système d'équations d'état temporel discret.
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Lorsque qu'un événement active le bloc (par son unique port événementiel)
l'état est alors mis à jour.
</FILE>

<FILE name='DLSS_f' type='LATEX'>
Ce bloc réalise un système d'équations d'état temporel discret.
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Lorsque qu'un événement active le bloc (par son unique port événementiel)
l'état est alors mis à jour.
</FILE>

<FILE name='DOLLAR' type='LATEX'>
Le bloc retard retarde ses entrées de la période spécifiée au niveau du port
d'entrée événementiel.
Ce bloc est équivalent à l'opérateur discret $z^{-1}$.
Il accepte une seule entrée et génére une seule sortie qui peuvent être
aussi bien un scalaire qu'un vecteur.
Si l'entrée est un vecteur alors tous les éléments du vecteur sont
retardés par la même période.
</FILE>

<FILE name='DOLLAR_f' type='LATEX'>
Le bloc retard retarde ses entrées de la période spécifiée au niveau du port
d'entrée événementiel.
Ce bloc est équivalent à l'opérateur discret $z^{-1}$.
Il accepte une seule entrée et génére une seule sortie qui peuvent être
aussi bien un scalaire qu'un vecteur.
Si l'entrée est un vecteur alors tous les éléments du vecteur sont
retardés par la même période.
</FILE>

<FILE name='DOLLAR_m' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        Le bloc retard retarde ses entrées de la période spécifiée au niveau
        du port d'entrée événementiel. Ce bloc est équivalent à l'opérateur
        discret z-1.
	Il accepte une seule entrée et génére une seule sortie qui peuvent
        être aussi bien un scalaire qu'un vecteur.
	Si l'entrée est un vecteur alors tous les éléments du vecteur sont
        retardés par la même période.
	</P>
	<P>
        Ce bloc supporte tous les types de données de scicos.
        Les types de données en entrée/sortie sont hérités du paramètre
        "initial condition".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DemoBlocks_pal' type='LATEX'>
Les blocs de cette palette sont utilisés pour faire des
diagrammes de démonstration.
</FILE>

<FILE name='Diode' type='LATEX'>
Ce composant consiste en une diode simple mise en parallèle avec une résistance
ohmique $R$. Le courant qui passe dans la diode est défini en
fonction de la tension aux bornes de le diode, {\it c.-à-d.},

\[I = I_{ds} (\exp^{v/V_t} - 1) + \frac {v} {R} \]

où $I_{ds}$ et $V_t$ sont le courant de saturation et la tension
équivalente de la température, respectivement. Si la valeur de $v/V_t$
atteint une certaine limite ($Maxexp$), la courbe caractéristique de
la diode devient linéaire pour éviter un dépassement numérique.
</FILE>

<FILE name='EDGETRIGGER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EDGE_TRIGGER' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='ENDBLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='END_c' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='ESELECT_f' type='LATEX'>
Bloc spécial similaire au bloc If-Then-Else. Les entrées/sorties
événementielles sont synchronisées. L'événement entrant est redirigé
sur l'un des ports de sortie événementiels suivant le valeur de
l'entrée régulière.
</FILE>

<FILE name='EVTDLY_c' type='LATEX'>
Chaque événement de sortie est réalisé après l'événement 
d'entrée par un laps de temps {\bf Delay}.\\
La date de l'événement de sortie est donc déterminée par la formule :
\begin{eqnarray}
 t_{i}&=&t_{\rm{init}} + i * T_{\rm{delay}},
\end{eqnarray}
</FILE>

<FILE name='EVTDLY_f' type='LATEX'>
Ce bloc génére à la sortie des événements retardés par rapport aux
événements qui arrivent à l'entrée.
Le retard est définit par la valeur du paramètre {\bf Delay}.
Ce bloc peut aussi généré un événement à une date initiale.
</FILE>

<FILE name='EVTGEN_f' type='LATEX'>
Un événement est généré sur le port unique de sortie événementiel
si la valeur du paramètre {\bf Event time} est plus grand ou égal à
zéro.
Si cette valeur est négative alors aucun événement ne sera généré.
</FILE>

<FILE name='EVTVARDLY' type='LATEX'>
Ce bloc génére à la sortie des événements retardés par rapport aux
événements qui arrivent à l'entrée.
Le retard est définit par la valeur qui est lu sur le port d'entrée
régulier.
Ce bloc peut aussi généré un événement à une date initiale.
</FILE>

<FILE name='EXPBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=a^u(i)$. 
Les tailles des ports d'entrée et de sortie sont déterminées par
le compilateur.
</FILE>

<FILE name='EXPBLK_m' type='LATEX'>
Ce bloc calcule $y(i)=a^u(i)$. \\
Les tailles des ports d'entrée et de sortie sont déterminées par
le compilateur.
</FILE>

<FILE name='EXPRESSION' type='LATEX'>
Le bloc EXPRESSION applique à son entrée les fonctions Scilab spécifiées
en paramètre.
</FILE>

<FILE name='EXTRACT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The EXTRACT block extracts some elements from the matrix.
          The size of the output depends on the number of rows and
          number of columns to extract.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTRACTBITS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block outputs a contiguous selection of bits from the input
        integer number.The Bits to extract defines the method by which
        the user select the output bits.
        </P>
	  <P>
          1- When "Upper Half" is selected the block outputs the half
             of the input that contain the most significant bit. In this
             case the third parameter "number of bits or index of bit"
             is ignored.
          </P>
	  <P>
          2- When "Lower Half" is selected the block outputs the half
             of the input that contain the least significant bit. In this
             case the third parameter "number of bits or index of bit"
             is ignored.
          </P>
	  <P>
          3- When "Range starting with most significant bit" is selected
             the block outputs certain number of bits of the input that
             contain the most significant bit. In this case the third
             parameter "number of bits or index of bit" defines the
             number of bits to extract.
          </P>
	  <P>
          4- When "Range ending with least significant bit" is selected
             the block outputs certain number of bits of the input that
             contain the least significant bit. In this case the third
             parameter "number of bits or index of bit" defines the
             number of bits to extract.
          </P>
	  <P>
          5- When "Range of bits" is selected the block outputs a range
             of bits of the input. In this case the third parameter
             "number of bits or index of bit" defines the range of bits
             to extract, it must be a vector with the format [start,end].
          </P>
	<P>
        The extracted value depends on the forth parameter "Treat bit
        field as an integer". When it is set to 0 the input scaling is
        used to determine the output scaling. When it is set to 1, only
        the extracted bits forms the output number.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTRACTOR' type='LATEX'>
Extrait ou sélectionne une entrée régulière parmi plusieurs entrées régulières.
</FILE>

<FILE name='EXTTRI' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The EXTTRI block extracts some elements from the input matrix u.
        </P>
	<P>
        When the "Extraction type" is set to "1", the block copies the
        elements on and above the main diagonal to an output matrix of
        the same size. The elements below the main diagonal are set to
        zero.
        </P>
	<P>
        When the "Extraction type" is set to "2", the block copies the
        elements on and below the main diagonal to an output matrix of
        the same size. The elements above the main diagonal are set to
        zero.
        </P>
	<P>
        When the "Extraction type" is set to "3", the block copies the
        elements on the main diagonal to an output matrix of the same
        size. The elements above and below the main diagonal are set to
        zero.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Electrical_pal' type='LATEX'>
La boîte à outils électrique contient les composants basiques
électriques tels que la source de tension, la diode, le condensateur,
etc.
</FILE>

<FILE name='Events_pal' type='LATEX'>
La palette 'Events' (événements) est utilisée pour manipuler les
événements sur le diagramme. Elle contient entre autre plusieurs
sources d'activation, des blocs synchrones ainsi que des blocs
pour regrouper/combiner les événements sur un seul lien.
</FILE>

<FILE name='Extract_Activation' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='FROM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The main role of the GOTO/FROM blocks is to transport signals
        from a block to another block without connecting them physically.
        The FROM block transports its received data (from the
        correponding GOTO) to its output. Multiples FROM blocks can
        receive data from one GOTO, although a GOTO can send data to
        multiple FROM.
        </P>
	<P>
        The GOTO and FROM blocks are connected by the tag parameter.
        </P>
	<P>
        For information on the visibility and limitation of these blocks
        please refer to the GOTO documentation.
        </P>
	<P>
        This block can support all the data types.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect modelica's blocks. For more
          information on how it works please refer to the documentation
          of the FROM block by clicking on the link in the "See also"
          field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMWSB' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    That block is used to get data defined in the Scilab workspace
    and use them in Scicos. Data should have "time" and "values" fields.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMWS_c' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
     This block is used in \htmladdnormallink{FROMWSB}{FROMWSB.htm} superblock.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FSV_f' type='XML'> 
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GAINBLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc GAINBLK calcule le produit d'une matrice carré A par une matrice
          d'entrée U, où le nombre de lignes/colonnes de A est égal au nombre de lignes
          de U. Les types de données des entrées/sorties sont définis par le type de
          donnée de la matrice gain A.
	  <P>
          Lorsqu'un dépassement intervient, le résulat peut prendre des valeurs
          différentes suivant le paramètre "DO ON OVERFLOW":
          </P>
	  <P>1- Un résulat non saturé.</P>
	  <P>2- Un résultat saturé.</P>
	  <P>3- Un message d'erreur est signalé lorsqu'un dépassement intervient.</P>
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GAINBLK_f' type='LATEX'>
Le bloc GAINBLK calcule le produit d'une matrice carré A par une matrice d'entrée U,
où le nombre de lignes/colonnes de A est égal au nombre de lignes de U.
</FILE>

<FILE name='GAIN_f' type='LATEX'>
Ce bloc calcule le produit d'une matrice carré A par une matrice d'entrée U, où le
nombre de lignes/colonnes de A est égal au nombre de lignes de U.
</FILE>

<FILE name='GENERAL_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GENSIN_f' type='LATEX'>
Ce bloc est un générateur de sinusoïde : $M*\sin(F*t+P)$
</FILE>

<FILE name='GENSQR_f' type='LATEX'>
Ce bloc est un générateur de signal carré : la sortie prend des valeurs
entre -M et M.
Pour chaque événement reçu, la sortie saute d'une valeur -M à M 
ou de M à -M.
</FILE>

<FILE name='GOTO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The main role of the GOTO/FROM blocks is to transport signals
        from a block to another block without connecting them physically.
        The GOTO block transports its input data to its corresponding
        FROM block. A simple GOTO block can send data to multiple FROM,
        although a FROM can receive data from only one GOTO.
        </P>
	<P>
        The GOTO and FROM blocks are connected by the tag parameter.
        </P>
	<P>
        The "Tag Visibility" parameter indicates if the location of
        the FROM block is limitted:
        </P>
	  <P>
          - Local: means that the corresponding FROM of that GOTO must
                   be in the same subsystem.
          </P>
	  <P>
          - Scoped: means that the corresponding FROM of that GOTO must
                    be in the same subsystem or in any subsystem below
                    the GotoTagVisibility block in the model hierarchy.
          </P>
	  <P>
          - Global: means that the corresponding FROM of that GOTO can
                    be anywhere in the model.
          </P>
	<P>
        This block can support all the data types.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GOTOMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect modelica's blocks. For more
          information on how it works please refer to the documentation
          of the GOTO block by clicking on the link in the "See also"
          field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibility' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block defines the accessibility of the GOTO block
          when it is configure as "scoped". The FROM block corresponding
          to that GOTO must be in the same subsystem of the
          GotoTagVisibility or in subsystems below it in the model
          hierarchy.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibilityMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used in case of modelica's connection.
          For more information on how it works please refer to the
          GotoTagVisibility block by clicking on the link in the
          "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Ground' type='LATEX'>
Cet élément est un composant électrique simple fournissant une tension
de référence dans des circuits électriques. Le potentiel au noeud de
Terre est zéro. Chaque circuit électrique doit contenir au moins un
élément Terre.
</FILE>

<FILE name='Gyrator' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
 A gyrator is a two-port element defined by the following equations:
    <SP>
    i1 =  G2 * v2
    </SP>
    <SP>
    i2 = -G1 * v1
    </SP>
where the constants G1, G2 are called the gyration conductance. 
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='HALT_f' type='LATEX'>
Ce bloc a un unique port d'entrée événementiel.
Lorsqu'un événement se présente sur ce port, alors la simulation
est arrêtée et la main est rendue à la fenêtre principale de Scicos.
La simulation peut être redémarrée ou continuée grâce au bouton Run.
</FILE>

<FILE name='HYSTHERESIS' type='LATEX'>
Permutte la valeur de la sortie entre deux constantes.
TODO
</FILE>

<FILE name='IFTHEL_f' type='LATEX'>
Ce bloc génére un événement sur l'une ses deux sorties événementielles
lorsqu'un événement en entrée active celui-ci.
Suivant le signe de la valeur lue sur le port d'entrée régulier,
l'événement est généré soit sur la branche 'then' ou bien sur la branche
'else'.
Ce bloc est un bloc synchrone, ce qui signifie que les événements en entrée
et en sortie sont générés exactement à la même date et simultanément.
</FILE>

<FILE name='IMPSPLIT_f' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='INIMPL_f' type='LATEX'>
Les ports d'entrée INIMPL\_f sont des liens qui permettent de connecter
l'intérieur d'un système vers l'extérieur.
</FILE>

<FILE name='INTEGRAL' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTEGRAL_f' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTEGRAL_m' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTMUL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The INTMUL block computes the matrix multiplication of two
        integers inputs matrices.The number of rows of the second
        matrix must be equal to the number of columns of the first
        matrix. The output is a matrix where the number of rows is
        equal to the number of rows of the first input matrix and
        the number of columns is equal to the number of columns of
        the second input matrix. This block support all the integer
        data type.
        </P>
	<P>
        On overflow, the result can take different forms:
        </P>
	 <P>1- A normal non saturated result.</P>
	 <P>2- A saturated result.</P>
	 <P>3- An error message warning the user about the overflow.</P>
	<P>
        The user can select one of these three forms by setting
        the "DO ON OVERFLOW" field to 0,1 or 2.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='INTRP2BLK_f' type='LATEX'>
La sortie de ce bloc est fonction de l'entrée obtenue par interpolation
bilinéaire.
Ce bloc a deux entrées scalaires et une seule sortie scalaire.
Les grandeurs $X(i)$ et $Y(i)$ donnent respectivement les coordonnées
$X,Y$ du $i^{\rm \grave{e}me}$ point de donnée et $Z(Y(i),X(i))$
sa valeur.
</FILE>

<FILE name='INTRPLBLK_f' type='LATEX'>
La sortie de ce bloc est fonction de l'entrée obtenue par interpolation
linéaire.
Ce bloc a une seule entrée scalaire et une seule sortie scalaire.
Les grandeurs $X$ et $Y$ donnent respectivement les coordonnées
$X,Y$ des points de données qui seront interpolés.
$X$ doit être strictement croissant.
</FILE>

<FILE name='INVBLK' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entrée/sortie est déterminée par le contexte.
</FILE>

<FILE name='INVBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entrée/sortie est déterminée par le contexte.
</FILE>

<FILE name='IN_f' type='LATEX'>
Ce bloc doit être utilisé dans un superbloc pour représenter un port
d'entrée régulier. La taille de ce port est automatiquement ajustée.
Dans un superbloc, les ports d'entrée réguliers doivent être numérotés
de 1 jusqu'au nombre de ports d'entrée réguliers composant le superbloc.
</FILE>

<FILE name='ISELECT_f' type='LATEX'>
Sélectionne des signaux suivant les événements d'entrée.
Ce bloc a un seul port régulier d'entrée.
</FILE>

<FILE name='ISELECT_m' type='LATEX'>
Sélectionne des signaux suivant les événements d'entrée.
Ce bloc a un seul port régulier d'entrée.
</FILE>

<FILE name='IdealTransformer' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
The ideal transformer is an ideal two-port resistive circuit element
which is characterized by the following two equations:
    <SP>
    v1 =  n * v2
    </SP>
    <SP>
    i2 = -n * i1
    </SP>
where n is a real number called the turns ratio. 
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Inductor' type='LATEX'>
Une bobine est un composant électrique qui peut stocker l'énergie
dans des circuits électriques.  Le rapport entre la tension $v$ aux
borne d'une bobine d'inductance $L$ et le courant $I$ passant à
travers le composant est donné par :

\[v = L \frac{dI}{dt}\]

 Des inductances peuvent également être utilisées pour distinguer les
 signaux haute fréquence des signaux de basse fréquence et ceci
 rend les inductances utiles dans la conception des filtres. Une
 inductance présente une forte impédance pour les signaux haute
 fréquence et est passante pour les signaux DC.
</FILE>

<FILE name='Integer_pal' type='LATEX'>
Cette palette est dédicacée aux nombres entiers.
Des opérateurs variés sont ici implémentés pour la logique
et la manipulation des champs de bits ainsi que des portes
logiques qui sont fréquemment utilisées dans les circuits numériques.
</FILE>

<FILE name='JKFLIPFLOP' type='LATEX'>
The JK flip flop is the most versatile of the basic flip-flops.
It has two inputs traditionaly labeled J and K. When J and K are
different, the output takes the value of J at the next falling edge.
When J and K are both low, no change occurs in the output state,
when they are both high the output will toggle from one state to other.
It can perform the functions of the set/reset flip-flop and has the
advantage that there are no ambiguous states. It can also act as a
T flip-flop to accomplish toggling action if J and K are tied together.
This toggle application finds extensive use in binary counters. 
This block is almostly used with digital number, the input data type
is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
J&
K&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
!Q(t-1)&
Q(t-1)\\
\hline
\end{tabular}
</FILE>

<FILE name='Keyboard_shortcuts' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='LOGBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=log(u(i))/log(a)$. 
Les tailles des ports d'entrée/sortie sont déterminés par le contexte.
</FILE>

<FILE name='LOGIC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block implements a standard truth table for modeling
          programming array, digital circuit and any other boolean
          expressions. The user can specify a matrix that defines all
          the possible block output in the Truth table field. Each row
          of the matrix contains the output of different combination
          of input elements. The number of rows must be a power of two,
          it defines the number of inputs using the equation:
        </P>
	<P>number of row = 2 ^ (number of input)</P>
	<P>
          The number of outputs is equal to the number of columns of
          the matrix.
        </P>
	<P>
          This block support only the int8 data type. When the input
          is positif, the input is considered as logical 1, When it is
          negatif or zero it is considered as logical 0.
        </P>
	<P>
          This block can be activated by an implicit input event or it
          can herit the clock from the regular input.
        </P>
	<P>
          This block is used to implement SR and JK flip-flops.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='LOGICAL_OP' type='LATEX'>
Le bloc Opérateur Logique réalise une opération logique
sur ses entrées qui est spécifiée en paramètre.
Une valeur d'entrée est VRAI (1), si elle est différente de zéro, et
elle est FAUSSE (0) si elle est égale zéro.
</FILE>

<FILE name='LOOKUP_f' type='LATEX'>
Ce bloc réalise une fonction non-linéaire qui est défini grâce à un
éditeur graphique.
</FILE>

<FILE name='Linear_pal' type='LATEX'>
Cette palette contient des opérateurs basiques et des sous-systèmes
linéaires.
</FILE>

<FILE name='Lorentz_diagr' type='LATEX'>
Le système de Lorentz est défini par le système continu
d'équations non-linéaires différentielles suivant :
\begin{eqnarray}
\frac{dx(t)}{dt}&=&a\left(-x(t)+y(t)\right)\\
\frac{dy(t)}{dt}&=&bx(t)-y(t)-x(t)y(t)\\
\frac{dz(t)}{dt}&=&-cx(t)+x(t)y(t)
\end{eqnarray}
Les variables d'états $x(t)$, $y(t)$ et $z(t)$ sont respectivement la température de
l'air, la vitesse du vent et une troisième variable qui représente la variation de la
température en fonction de l'altitude.
</FILE>

<FILE name='MATBKSL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATBKSL block outputs the left matrix division. It is
          a solution to A*x=B. The higher input is the A matrix, the
          lower one is the B matrix, and the output is x. If A is an
          M-by-N1 matrix, B must be a M-by-N2 where N1 and N2 can be
          different or equal.
	  The output x is a N1-by-N2 matrix.
        </P>
	<P>
          The equivalent of BACKSLASH is "\" in Scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATCATH' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATCATH Block outputs the horizontal concatenation
          of multiple matrices. It is also called concatenation
          according to the columns. The inputs U1,U2,...,Un must
          have the same number of rows. The output is a
          M-by-(N1+N2+...+Nn) matrix, where N1,N2,...,Nn are the
          numbers of columns of the inputs matrices, and M is the
          number of rows.
	</P>
	<P>
          The equivalent of MATCATH in Scilab is y=[U1 U2 ... Un].
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATCATV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATCATV Block outputs the vertical concatenation of
          multiple matrices. It is also called concatenation according
          to the rows. The inputs U1,U2,...,Un must have the same
          number of columns. The output is a (M1+M2+...+Mn)-by-N
          matrix, where M1,M2,...,Mn are the numbers of rows of the
          inputs matrices, and N is the number of columns.
	</P>
	<P>
          The equivalent of MATCATH in Scilab is y=[U1;U2;...;Un]
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDET' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATDET outputs the determinant of a square input matrix.
        If the input A=[A11 A12 A13;A21 A22 A23;A31 A32 A33] then the
        output of the block has the form of:
        y=A11*(A22*A33-A23*A32)-A12*(A21*A33-A23*A31)+A13*(A21*A32-A22*A31).
       </P>
	<P>
        The equivalent of MATDET in Scilab is "det"
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDIAG' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATDIAG block create a diagonal matrix from a 1D vector.
          If the input is a M-by-1 vector than the output is an M-by-M
          matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDIV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        The MATDIV block outputs the right matrix division. It is a
        solution to x*B=A. The higher input is the A matrix, the lower
        one is the B matrix, and the output is x. If A is an M1-by-N
        matrix, B must be a M2-by-N where M1 and M2 can be different
        or equal. The output x is a M1-by-M2 matrix.
        </P>
	<P>
        The equivalent of BACKSLASH is "/" in Scilab.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATEIG' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATEIG calculate the eigenvalues and the eigenvectors
        of a square input matrix U.
        </P>
	<P>
        When the "Decomposition type" is set to 1, the block outputs
        the eigenvalues in a vector form, if the input is a M-by-M
        matrix the output is a M-by-1 vector.
        </P>
	<P>
        When the "Decomposition type" is set to 2, the block outputs
        two matrices. for an M-by-M input matrix,the first output is
        a M-by-M diagonal matrix composed by the eigenvalues, and the
        second is a M-by-M matrices composed by the eigenvectors; the
        eigenvectors are represented by the columns of the matrix.
        </P>
	<P>
        The equivalent of the MATEIG block in Scilab is "spec(A)"
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATEXPM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATEXPM outputs the matrix exponential of a square
          matrix input by the pade's approximants. The output is
          a square matrix with the same size of the input. The
          equivalent of this block in Scilab is "expm".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATINV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATINV Block outputs the inverse of a square input matrix
          using the LU factorization. A warning message is printed if
          the input is badly scaled or nearly singular. The equivalent
          function of this block in Scilab is "inv".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATLU' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATLU Block outputs two matrices L and U, with row
          pivoting, from the LU factorization of a square input
          matrix. If A is the input matrix then E*A=L*U where E
          is the permutation matrix.The equivalent function of
          this block in Scilab is "[l,u,e]=lu(A)"
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATMAGPHI' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>MATMAGPHI Block has two types of decomposotions.</P>
	<P>
        When the type is set to one, the block converts a complex
        number to the magnitude and the radian angle, in this case
        the input is complex and the outputs are real double. If
        the input is real double, the angle will be zero or PI and
        the magnitude will be equal to the absolute of the input number.
        </P>
	<P>
        When the type is set to two, the block outputs a complex number
        given the magnitude and the radian angle. In this case the inputs
        are real double and the output is complex.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATMUL' type='XML'>
<DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc MATMUL fait la multiplication matricielle de ses deux entrées. Le
          nombre de lignes de la seconde matrice doit être égal au nombre de colonnes
          de la première. La sortie est une matrice où le nombre de lignes est égal à
          celui de la première matrice d'entrée et où le nombre de colonnes est égal à
          celui de la deuxième matrice d'entrée.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATPINV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATPINV Block outputs the inverse of a non square input
        matrix using the SVD theory.if the SVD decomposition of A is
        equal to:
        </P>
	 <P>A=USV'</P>
	<P>
        The pseudoinverse x of A is given by:
        </P>
	 <P>X=VS"U' where S"(i,j)=1/S(i,j) (if S(i,j)~=0),
	    U' and V are respectivly the transpose of U and V'.
         </P>
	<P>
        and we have A*X*A=A and X*A*X=X. Both A*X and X*A
        are Hermitian . A warning message is printed if the input
        is badly scaled or nearly singular.
        </P>
	<P>
        When the input is a M-by-N matrix the output is a
        N-by-M matrix. The eqivalent function of this block
        in Scilab is "pinv".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATRESH' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The RESHAPE block changes the dimensions of a matrix or
          a vector to another dimensions specified by the user in
          the "output size desired" label. The output size must be
          less or equal to the input size.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATSING' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        The MATSING block computes the economy sized SVD of the
        M-by-N input matrix A by finding U,S and V such that
        </P>
	 <P>A=U*S*V'.</P>
	<P>
        When the decomposition type is set to one, the output is
        a vector composed by the singular values.
        </P>
	<P>
        When the decomposition type is set to two, we have three
        outputs: the second output is a diagonal matrix S composed
        by the singular values and the other two outputs are the
        unitary matrices U and V.
        </P>
	<P>
        The equivalent function of this block in Scilab is "svd".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATSUM block returns the sum of the element of an input matrix/vector.
	  When the Sum along is set to all the block outputs the sum of all the
          elements of the matrix. The output is then a scalar.
	  When the Sum along is set to lines the block is a rowwise sum. The output is
          a row vector.
	  When the Sum along is set to Columns the block is a columnwise sum. The
          output is a column vector.
	  The equivalent function of this block in scilab is: "sum".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATTRAN' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc fait la transposition d'une matrice de taille MxN en matrice de
          taille NxM. Pour les données de type complexe, celui-ci utilise une
          transposition Hermitienne. L'instruction scilab équivalente de ce bloc est
          y=u'.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZCONJ' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks computes the conjugate of a complex input matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZREIM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block decomposes a complex number by seperating the real
          and imaginary parts or compose a comples number by joining the
          two parts. The user can select even to seperate or to join real
          and imaginary part by setting the decomposition type to 1 or 2.
          When it is set to 1, the input is a complex matrix and the
          outputs are the real and imaginary parts of the input. When it
          set to 2, The inputs are two real matrices, the output is a
          complex number with real part the first input and imaginary
          part the second input.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MAXMIN' type='LATEX'>
Ce bloc peut trouver aussi bien le maximum que le minimum dans les
éléments de ses entrées.
La fonction min ou max peut être choisie dans les paramètres de la
boîte de dialogue.
</FILE>

<FILE name='MAX_f' type='LATEX'>
Ce bloc trouve la valeur maximale dans les éléments
de son vecteur d'entrée.
</FILE>

<FILE name='MBLOCK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    The block "MBlock" provides an easy way to build a Scicos block
    whose behavior is specified by a Modelica program.  Using this
    block, the user will be able to write and compile Modelica
    programs in Scicos without creating any interfacing function.  The
    associated Modelica program of this block can be either given in a
    file or written in the window opened by the block. In order to
    link this block to other Scicos blocks that may be other Modelica
    blocks, the types of block ports' as well as their associated variables
    should be specified.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MCLOCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MEMORY_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MFCLCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MIN_f' type='LATEX'>
Ce bloc trouve la valeur minimale dans les éléments
de son vecteur d'entrée.
</FILE>

<FILE name='MOTOR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MUX' type='LATEX'>
Ce bloc regroupe $n$ vecteurs d'entrée en un seul vecteur à la sortie.
La sortie est $y=[u_1;u_2;\cdots;u_n]$ , où les $u_i$ numérotées dans
un ordre croissant correspondent aux ports réguliers d'entrée du haut
vers le bas.
Les tailles d'entrée/sortie sont soit déterminées automatiquement
à la compilation ou alors déterminées par le paramètre
{\bf number of input ports or vector of sizes}.
</FILE>

<FILE name='MUX_f' type='LATEX'>
Ce bloc regroupe $n$ vecteurs d'entrée en un seul vecteur à la sortie.
La sortie est $y=[u_1;u_2;\cdots;u_n]$ , où les $u_i$ numérotées dans
un ordre croissant correspondent aux ports réguliers d'entrée du haut
vers le bas.
Les tailles d'entrée/sortie sont soit déterminées automatiquement
à la compilation ou alors déterminées par le paramètre
{\bf number of input ports or vector of sizes}.
</FILE>

<FILE name='M_SWITCH' type='LATEX'>
The Multi-Port Switch block chooses between a number of inputs. The
first (top) input is called the control input, while the rest of the
inputs are called data inputs. The value of the control input
determines which data input is passed through to the output port.
</FILE>

<FILE name='M_freq' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This blocks generates events at specific sample time of the
        simulation time. The sample time is given in the "Sample Time"
        field and the offset is given in the "Offset" field. This
        block has one event input, the number of event outputs depends
        on the number of different sample time. For exemple if the vector
        of sample time is [1 1 2] and the vector of offset is [0 .5 0]
        then the block has 7 outputs.
        </P>
	<P> - The first output is activated when the simulation time
              is equal to a multiple of the first sample time plus
              the first offset
        </P>
	<P> - The second output is activated when the simulation time
              is equal to a multiple of the second sample time plus
              the second offset.
        </P>
	<P> - The third output is activated when we have both cases,
              first case and second case.
        </P>
	<P> - The fourth output is activated when the simulation time
              is equal to a multiple of the third sample time plus
              the third offset.
        </P>
	<P> - The fifth output is activated when we have both cases,
              first case and forth case.
        </P>
	<P> - The sixth output is activated when we have both cases,
              second case and fourth case.
        </P>
	<P> - The seventh output is activated when we have both cases,
              third case and forth case.
        </P>
	<P> etc...</P>
	<P>
        So the number of outputs is equal to 2**number of differents
        time values. Each of these time values is represented by a
        binary number associated to the output's number in decimal.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Matrix_pal' type='LATEX'>
Cette palette contient tous les blocs dont vous avez
besoin pour réaliser des opérations matricielles 
simples et complexes.
</FILE>

<FILE name='Menu_entries' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='Modulo_Count' type='LATEX'>
Ce bloc est un bloc discret.
Il délivre un signal scalaire périodique qui a une forme déterminée
par les choix de l'utilisateur.
</FILE>

<FILE name='Multiwindow' type='LATEX'>
\subsection{Introduction}
A serious limitation of the Scicos editor has been its inability to
handle more than one diagram at a time. This limitation has been
lifted; it is now possible to open and edit multiple diagrams as
long as they are sub-diagrams of the same Scicos model. In most cases,
the multi-window editing is needed in this situation. The extension
that would allow the simultaneous editing of multiple Scicos models is
forthcoming.  

There are a number of new functionalities available in the new editor
for taking advantage of its muti-windows capabilites. This document
gives a brief description of these functionalities.

\subsection{Active diagram}
In the new editor multiple diagrams can be simultaneously
open. Standard object editing capabilities are available in all of the
diagrams as usual (but not palettes which are read only). But editing
across diagrams is also allowed. For example a block can be ``copied''
in one diagram and ``pasted'' to another one. 

Any action on a diagram window, such as clicking or selecting a menu,
activates the diagram. In most cases the user does not care which
diagram is active because most operations activate the diagram in
which the action has taken place immediately in a completely
transparent manner. 

When a diagram is activated, all the necessary steps are taken by
Scicos to make sure that the environment of the diagram is up to
date. In particular, the symbolic parameters defined in the context of
the diagram and all other diagrams above it are available. This
implies that the user can start editing the diagram without any risk
of inconsistency with the rest of the model.

In most cases, inactive diagrams are also up to date. There is however
an exception. If the number of input/output ports of a Super Block is
modified, the parent diagram is affected. If the parent diagram is
open, it should be updated. This modification however is not
materialized until either the first diagram is closed or the parent
diagram is activated. Once again there is no risk in creating any
inconsistency because the parent diagram, which may not be up to date
at a given time, cannot be edited without being activated.


\subsection{Scicos Browser}
It is very easy to lose track of the topology of a model when many
diagrams are open at the same time. To obtain a hierachical view of
the structure of the model, a Browser functionality has been made
available. The Browser gives a global view of the full model as a tree
like structure. It also indicates the node corresponding to the active
diagram (diagram in which the Browser operation has been launched). 

The Browser is more than just a viewing facility. By double clicking
on a node in the Browser, the corresponding diagram is activated
(opened first if not already open). The main diagram, which
is the root of the tree like structure in the Browser, is not a
node. To activate the main diagram use the
``Diagram/Up\_to\_Main\_diagram'' menu. 

Note that the Browser display is not updated dynamically as the diagram is
edited. So if a Super Block is removed or a new one is created, the
tree structure would no longer be correct. In that case the Browser must
be launched again.

\subsection{Limited Undo operations}
Scicos has always had a single step undo facility. This has not
been really improved in the new editor, however, now each diagram has
its own single step undo facility. In most cases the undo operations
are independent from one window to another, but there is an
exception. If a low-level diagram of a diagram is edited, the undo
operation in this latter diagram can undo all the editing done in the
low-level diagram since it has been opened. To avoid loss of work by an
inadvertent undo, a war

\subsection{Scilab window activation}
</FILE>

<FILE name='NEGTOPOS_f' type='LATEX'>
Un événement est généré lorsque l'unique entrée de ce bloc traverse
la valeur zéro lors d'un front montant.
</FILE>

<FILE name='NMOS' type='LATEX'>

The NMos model is a simple model of a n-channel metal-oxide
semiconductor FET. It differs slightly from the device used in the
SPICE simulator. For more details please care for H. Spiro.

The model does not consider capacitances. A small fixed drain-source
resistance is included (to avoid numerical difficulties).
\begin{table}[h!b!p!]
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
 W [m] & L [m] &  Beta [1/V^2]& Vt [V] &  K2 & K5 & DW [m]& DL[m] & \\
\hline
  12.e-6&  4.e-6&  .062  &   -4.5   &   .24 &     .61  &   -1.2e-6 &    -.9e-6 &        depletion\\
  60.e-6&  3.e-6&  .048  &     .1   &  .08  &    .68   &  -1.2e-6  &   -.9e-6  &       enhancement\\
  12.e-6&  4.e-6&  .0625 &    -.8   &   .21 &     .78  &   -1.2e-6 &    -.9e-6 &        zero\\
  50.e-6&  8.e-6&  .0299 &     .24  &  1.144&     .7311&   -5.4e-6 &   -4.e-6  &        \\
  20.e-6&  6.e-6&  .041  &     .8   &  1.144&     .7311&   -2.5e-6 &   -1.5e-6 &        \\
  30.e-6&  9.e-6&  .025  &   -4.    &   .861&     .878 &   -3.4e-6 &   -1.74e-6&        \\
  30.e-6&  5.e-6&  .031  &     .6   &  1.5  &     .72  &    0      &   -3.9e-6 &        \\
  50.e-6&  6.e-6&  .0414 &   -3.8   &   .34 &     .8  &    -1.6e-6 &   -2.e-6  &        depletion\\
  50.e-6&  5.e-6&  .03   &     .37  &   .23 &     .86 &    -1.6e-6 &   -2.e-6  &        enhancement\\
  50.e-6&  6.e-6&  .038  &    -.9   &   .23 &     .707&    -1.6e-6 &   -2.e-6  &        zero\\
  20.e-6&  4.e-6&  .06776&     .5409&   .065&     .71 &     -.8e-6 &    -.2e-6 &        \\
  20.e-6&  4.e-6&  .06505&     .6209&   .065&     .71 &     -.8e-6 &    -.2e-6 &        \\
  20.e-6&  4.e-6&  .05365&     .6909&   .03 &     .8  &     -.3e-6 &    -.2e-6 &       \\
  20.e-6&  4.e-6&  .05365&     .4909&   .03 &     .8  &     -.3e-6 &    -.2e-6 &       \\
  12.e-6&  4.e-6&  .023  &   -4.5   &   .29 &     .6  &     0      &    0      &        depletion\
  60.e-6&  3.e-6&  .022  &     .1   &   .11 &     .65 &     0      &    0      &        enhancement\\
  12.e-6&  4.e-6&  .038  &    -.8   &   .33 &     .6  &     0      &    0     &         zero\\
  20.e-6&  6.e-6&  .022  &     .8   &  1    &     .66 &     0      &    0     &       \\
\hline
\end{tabular}
\end{table}

</FILE>

<FILE name='NPN' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un modèle simple pour le transistor bipolaire NPN basé sur
le modèle  Ebers-Moll.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='NRMSOM_f' type='LATEX'>
The Merge block combines its inputs into a single output line whose
value at any time is equal to the most recently computed output of its
driving blocks. You can specify any number of inputs by setting the
block's Number of inputs parameter.  
</FILE>

<FILE name='Non_linear_pal' type='LATEX'>
Cette palette contient des fonctions non-linéaires.
</FILE>

<FILE name='OUTIMPL_f' type='LATEX'>
Les ports de sortie OUTIMPL\_f sont des liens qui permettent de connecter
l'extérieur d'un système vers l'intérieur.
</FILE>

<FILE name='OUT_f' type='LATEX'>
Ce bloc doit être utilisé dans un superbloc pour représenter un port
de sortie régulier. La taille de ce port est ajustée automatiquement.
Dans un superbloc, les ports de sortie réguliers doivent être numérotés
de 1 jusqu'au nombre de ports de sortie réguliers composant le superbloc.
</FILE>

<FILE name='OldBlocks_pal' type='LATEX'>
Cette palette contient des anciens blocs Scicos.
Elle est fournie pour pouvoir assurer la compatibilité
avec des anciens diagrammes contenant ces anciens blocs.
</FILE>

<FILE name='OpAmp' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
The ideal OpAmp is a two-port. The left port is fixed to v1=0 and i1=0
(nullator). At the right port both any voltage v2 and any current i2
are possible (norator).
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Others_pal' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='PDE' type='LATEX'>
This block is an implementation of several numerical schemes (Finite Elements (1st and 2nd order),
Finite Differences (1st and 2nd order), Finite Volumes (1st order)) to solve mono dimensional 
PDE (Partial Differential Equation) within SCICOS.
The mathematical framwork was restricts in PDEs linear scalars with maximum order 2 in time and space.
The goal is to provide engineers and physicists with an easy to use toolbox in SCICOS that will let them
graphically describe the PDE to be solved. A decision system selects the most efficient numerical scheme
depending on the type of the PDE and runs the solvers.
</FILE>

<FILE name='PID' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ce bloc implémente un régulateur PID. Un régulateur Proportionnel Intégral
Dérivé (PID) est un organe de contrôle permettant dâeffectuer une régulation en
boucle fermée dâun système industriel. Câest le régulateur le plus utilisé dans lâindustrie et permet de contrôler la grande majorité des
procédés.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='PMOS' type='LATEX'>

The PMOS model is a simple model of a p-channel metal-oxide
semiconductor FET. It differs slightly from the device used in the
SPICE simulator. For more details please care for H. Spiro.

The model does not consider capacitances. A small fixed drain-source
resistance is included (to avoid numerical difficulties).

Some typical parameter sets are:

\begin{table}[h!b!p!]
\begin{tabular}{ |c|c|c|c|c|c|c|c|}
\hline
 W [m]&L[m]&Beta [1/V^2]&Vt [V]& K2 & K5&  DW [m]& DL [m]
\hline
  50.e-6 &8.e-6 &.0085    &-.15 &   .41  &   .839  & -3.8e-6  & -4.0e-6  
  20.e-6 &6.e-6 &.0105    &-1.0 &    .41 &    .839 &  -2.5e-6 &  -2.1e-6 
  30.e-6 &5.e-6 &.0059    &-.3  &   .98  &  1.01   &  0       & -3.9e-6   
  30.e-6 &5.e-6 &.0152    &-.69 &   .104 &  1.1    &  -.8e-6  &  -.4e-6         
  30.e-6 &5.e-6 &.0163    &-.69 &   .104 &  1.1    &  -.8e-6  &  -.4e-6         
  30.e-6 &5.e-6 &.0182    &-.69 &   .086 &  1.06   &  -.1e-6  &  -.6e-6         
  20.e-6 &6.e-6 &.0074    &-1.  &    .4  &    .59  &   0      &   0           
\hline
\end{tabular}
\end{table}
</FILE>

<FILE name='PNP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un modèle simple pour le transistor bipolaire PNP basé sur
le modèle  Ebers-Moll.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='POSTONEG_f' type='LATEX'>
Un événement est généré lorsque l'unique entrée de ce bloc traverse
la valeur zéro lors d'un front descendant.
</FILE>

<FILE name='POWBLK_f' type='LATEX'>
Ce bloc réalise $y(i)=u(i)^a$.
Les tailles des ports d'entrée/sortie sont déterminées par le
compilateur.
</FILE>

<FILE name='PRODUCT' type='LATEX'>
The Product block performs multiplication or division of its
inputs. This block produces outputs using either element-wise or
matrix multiplication, depending on the value of the Multiplication
parameter. You specify the operations with the Number of inputs
parameter. Multiply(+1) and divide (-1) characters indicate the
operations to be performed on the inputs.
</FILE>

<FILE name='PROD_f' type='LATEX'>
La sortie de ce bloc est le produit élément par élément des entrées.
</FILE>

<FILE name='PerteDP' type='LATEX'>
Un bloc de PertDP représente un tuyau hydraulique avec des pertes de
charge. Ce composant représente une perte de charge hydraulique où la
perte de pression est directement proportionnelle au débit, état
laminaire.  Ce bloc a une direction; c.-à-d. la direction positive est
quand le fluide entre par le port d'entrée (le noir). Ceci signifie
que ce bloc suppose que le débit est positif si le fluide découle du
port noir vers le port blanc.  Les paramètres importants de ce composant
sont la longueur, le diamètre du tuyau, les altitudes des ports
d'entrée et de sortie, et quelques autres coefficients
thermo-hydrauliques.
</FILE>

<FILE name='PotentialSensor' type='LATEX'>
Ce bloc est employé pour mesurer la tension d'un noeud par rapport à
celle de terre (zero) dans un circuit électrique. La tension est
donnée à la partie explicite du modèle par un port explicite.
</FILE>

<FILE name='PuitsP' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce composant représente un puit thermo-hydraulique de
	  pression constante. Ce bloc est défini avec sa pression
          et sa température. La direction positive est quand le
          fluide coule dans le bloc.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='QUANT_f' type='LATEX'>
Ce bloc quantifie le signal d'entrée suivant les méthodes choisies :
\begin{enumerate}
\item méthode 'Round' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)-0.5) &\texttt{si} \; u(i)<0 .\\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)+0.5) &\texttt{si} \; u(i)>=0 .
\end{eqnarray}
\item méthode 'Truncation' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)) &\texttt{si} \; u(i)<0 .  \\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)) &\texttt{si} \; u(i)>=0 .
\end{eqnarray}
\item méthode 'Floor' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5))  .
\end{eqnarray}
\item  méthode 'Ceil' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5))
\end{eqnarray}
\end{enumerate}
</FILE>

<FILE name='RAMP' type='LATEX'>
Le bloc RAMP génére un signal qui commence à une date et à une valeur
spécifiées et évolue suivant une pente donnée.
Les paramètres {\bf Slope , Start time} et {\bf Initial output} déterminent
les caractéristiques du signal de sortie.
Ces paramètres doivent avoir des dimensions identiques.
</FILE>

<FILE name='RAND_f' type='LATEX'>
Ce bloc est un générateur de nombres aléatoires : chaque composante de sortie
prend des valeurs constantes aléatoires par morceaux. Pour chaque événement les
sorties prennent des nouvelles valeurs indépendantes.\\
La taille du port de sortie est déterminée par la taille des vecteurs {\bf A} et {\bf B}.
</FILE>

<FILE name='RAND_m' type='LATEX'>
Ce bloc est un générateur de nombres aléatoires : chaque composante de sortie
prend des valeurs constantes aléatoires par morceaux. Pour chaque événement les
sorties prennent des nouvelles valeurs indépendantes.\\
La taille du port de sortie est déterminée par la taille des matrices {\bf A} et {\bf B}.
</FILE>

<FILE name='RATELIMITER' type='LATEX'>
The Rate Limiter block limits the first derivative of the signal
passing through it. The output changes no faster than the specified
limit.
</FILE>

<FILE name='READAU_f' type='LATEX'>
Charge un son enregistré dans un fichier 'au'.
Les données échantillonnées seront écrites sur la sortie y du bloc.
Si l'extension du fichier n'est pas spécifiée alors l'extension '.au' est
automatiquement ajoutée.
Les valeurs d'amplitude sont comprises entre [-1,+1].
La lecture 'au' supporte les données multi-canaux sous les formats suivants :
\begin{itemize}
   \item 8-bit mu-law 
   \item 8-, 16-, and 32-bit linear
   \item Floating-point
\end{itemize}
</FILE>

<FILE name='READC_f' type='LATEX'>
Ce bloc permet de lire des données dans un fichier C.
Les paramètres {\bf Output record selection] et {\bf Time record Selection}
permettent de sélectionner des données dans les enregistrements du fichier.
Chaque appel au bloc, fait avancer d'un enregistrement dans le fichier.
</FILE>

<FILE name='REGISTER' type='LATEX'>
Ce bloc réalise un registre à décalage.
Pour chaque événement d'entrée, le registre est décalé d'un élément.
</FILE>

<FILE name='REGISTER_f' type='LATEX'>
Ce bloc réalise un registre à décalage.
Pour chaque événement d'entrée, le registre est décalé d'un élément.
</FILE>

<FILE name='RELATIONALOP' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='RELAY_f' type='LATEX'>
This block routes one of the regular inputs to the unique regular
output. the choice of which input is to be routed is done, initially
by the "initial connected input" parameter. Then, every time an input
event arrives on the i-th input event port, the i-th regular input
port is routed to the regular output.
</FILE>

<FILE name='RFILE' type='LATEX'>
Ce bloc permet à l'utilisateur de lire des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Les paramètres {\bf  Output record selection} et {\bf Time record selection}
permettent de selectionner des données parmi les enregistrements du fichier.
Chaque appel au bloc avance d'un enregistrement.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{WFILE}{WFILE.htm}.
</FILE>

<FILE name='RFILE_f' type='LATEX'>
Ce bloc permet à l'utilisateur de lire des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Les paramètres {\bf  Output record selection} et {\bf Time record selection}
permettent de selectionner des données parmi les enregistrements du fichier.
Chaque appel au bloc avance d'un enregistrement.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{WFILE\_f}{WFILE_f.htm}
</FILE>

<FILE name='RICC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block computes the solution of riccati equation using
        different method and for both case continuous and discrete.
        </P>
	<P> The riccati equation in continuous time is:</P>
	<P>     A*X+X*A+C-X*D*X=0 </P>
	<P> The riccati equation in discrete time is:</P>
	<P>     A*X*(inv(In-D))*A-X+C=0</P>
	<P>
         where A is an NxN matrix, it is the first input of the block,
         C and D are two NxN symetrics matrices and are respectivly the
         second and third input of the RICC block. X represent the
         output of the block, it is also a NxN matrix.
        </P>
	<P>
         The user can choose between two methods of computation. For the
         continuous time he can use even the Schur method or the matrix
         sign function approach method, by setting the Model parameter
         to 1 or 2. For the discrete time, the models are the Schur
         method and the inverse free spectral decomposition method.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='ROOTCOEF' type='LATEX'>
Ce bloc calcule les coefficients d'un polynôme grâce aux valeurs
des racines.
</FILE>

<FILE name='Resistor' type='LATEX'>
Une résistance est un composant électrique à deux ports qui résiste à
un courant électrique en produisant une chute de tension ($V$) : la loi
d'Ohm.

 \[ R = \frac {V}{I}\] 

  La résistance électrique ($R$) est égale à la chute de tension entre
les ports de la résistance divisée par le courant qui passe au travers
($I$).
</FILE>

<FILE name='SAMPHOLD' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SAMPHOLD_m' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SAMPLEHOLD_f' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SATURATION' type='LATEX'>
Le bloc saturation impose des limites maximale et minimale sur un signal.
Lorsque le signal est compris dans l'échelle définie par les paramètres
{\bf Upper limit} et {\bf Lower limit}, celui ci est reporté à la sortie
sans modifications.
Lorsque le signal sort de ces limites, alors le signal sature à la sortie
du bloc.
</FILE>

<FILE name='SAT_f' type='LATEX'>
Le bloc saturation impose des limites maximale et minimale sur un signal.
Lorsque le signal est compris dans l'échelle définie par les paramètres
{\bf Upper limit} et {\bf Lower limit}, celui ci est reporté à la sortie
sans modifications.
Lorsque le signal sort de ces limites, alors le signal sature à la sortie
du bloc.
</FILE>

<FILE name='SAWTOOTH_f' type='LATEX'>
Ce bloc est un générateur de dents de scie : 
la sortie de ce bloc est calculée par $(t-t_i)$ de $t_i$ jusqu'à $t_{i+1}$
où $t_i$ et $t_{i+1}$ sont les instants de deux événements d'entrée successifs.
</FILE>

<FILE name='SCALAR2VECTOR' type='LATEX'>
Ce bloc convertit une valeur scalaire en un vecteur.
Lorsque des blocs avec plus d'un port régulier son utilisés (comme Somme
ou le bloc Relational Operator), vous pouvez mixer des entrées scalaires
et vectorielles.
Lorsque vous faites cela, les entrées scalaires sont étendues à des vecteurs
dont les tailles sont égales aux tailles des vecteurs d'entrée.
Si plus d'un port d'entrée est vectoriel, alors ils doivent avoir la même taille.
</FILE>

<FILE name='SELECT_f' type='LATEX'>
Ce bloc redirige l'une de ses entrées régulières sur l'unique
sortie régulière.
Le choix qui est fait pour savoir quel est le port d'entrée redirigé
est initalement fait par le paramètre {\bf initial connected input}.
Pendant la simulation, à chaque fois que ce bloc est activé par son
entrée événementielle $i$, alors la valeur présente sur le
 $i^{\rm \grave{e}me}$ port régulier est recopiée sur la sortie. 
</FILE>

<FILE name='SELECT_m' type='LATEX'>
Un bloc selecteur accepte sur son entrée aussi bien un vecteur qu'une matrice.
Vous pouvez définir le paramètre {\bf Input Type} au type de signal que vous
utilisez dans votre modèle (matrice ou vecteur).
Les paramètres de la boîte de dialogue et l'aspect du bloc changent en accord
avec le type de l'entrée, ainsi que la manière dont il détermine les éléments 
à sélectionner.
%Ce bloc redirige l'une de ses entrées régulières sur l'unique
%sortie régulière.
%Le choix qui est fait pour savoir quel est le port d'entrée redirigé
%est initalement fait par le paramètre {\bf initial connected input}.
%Pendant la simulation, à chaque fois que ce bloc est activé par son
%entrée événementielle $i$, alors la valeur présente sur le
% $i^{\rm \grave{e}me}$ port régulier est recopiée sur la sortie.
</FILE>

<FILE name='SHIFT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block shifts the bits of the input signal. In this
          operation the digits are moved to the right or to the left.
	  The user can choose the rule to shifts the bits. It can be
          normal or cycle by setting the "Shifttype" parameter to "0"
          or "1".
        </P>
	<P>
          When the Shifttype is 0, an arithmetic shift is applied to the
          input signal. In this case, the bits that are shifted out of
          either end are discarded. Zeros are shifted in on the right,
          in the case of left shift; in the case of right shifts, copies
          of the sign bit is shifted in on the left.
        </P>
	<P>
          When the "Shifttype" is 1,a circular shift is applied to the
          input signal. In this case, the bits are rotated as if the left
          and right ends of the register are joined. The value that is
          shifted in on the right during a left-shift is whatever values
          was shifted out on the left, and vice versa.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SIGNUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SINBLK_f' type='LATEX'>
$$y={\rm sin}(u)$$
</FILE>

<FILE name='SLIDER_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='SQRT' type='LATEX'>
Ce bloc calcule les racines carré de cahque élément de la matrice d'entrée.
Il supporte les types de donnée réels et complexes.
</FILE>

<FILE name='SRFLIPFLOP' type='LATEX'>
This block describe the simplest and the most fundamental latch
the SR flip flop. Where S and R are the input and Q and !Q are the
outputs.If S (Set) is pulsed high while R is held low, then the Q
output is forced high, and stays high when S returns low; similarly,
if R (Reset) is pulsed high while S is held low, then the Q output
is forced low, and stays low when R returns low. When both are low,
Q(t) takes the same state as Q(t-1). When they are both high, both Q
and !Q take the low values we are in an unstable state. Practicaly we
have to avoid this case.This block is almostly used with digital
number, the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
S&
R&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
0&
0\\
\hline --> This case is to avoid
\end{tabular}
</FILE>

<FILE name='STEP' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='STEP_FUNCTION' type='LATEX'>
Le bloc 'Step' réalise un saut entre deux niveaux définis à un temps
spécifié.
Si le temps de simulation est inférieur au paramètre {\bf Step time}, la 
sortie est égale à la valeur du paramètre {\bf Initial value}.
Pour les temps de simulation supérieurs, la sortie est égale à la valeur
du paramètre {\bf Final value}.
</FILE>

<FILE name='SUBMAT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block outputs a sub matrix of the input matrix.
          The output matrix will be defining by using the parameters
          of this block.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUMMATION' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P> Ce bloc fait l'addition ou la soustraction de ses entrées. Ce bloc
	peut additioner et soustraire des grandeurs scalaires, vectorielles et
	matricielles. Il peut aussi faire la somme cumulative d'une seule entrée
	vectorielle.</P>
	<P>
        Le nombre d'entrée est donné par le second paramètre de la boite de dialogue.
        Ce paramètre peut être un vecteur de nombre +1 et -1 ou bien
	il peut être une seule valeur positive. Dans le premier cas le vecteur donne le
        nombre d'entrée et le signe indique si c'est une addition ou une soustraction.
        Pour le second choix, ce bloc est un additionneur dont le nombre d'entrée est
        déterminée par la valeur de ce paramètre.
        </P>
	<P>
        Lorsqu'un dépassement intervient, le résulat peut prendre des valeurs
        différentes suivant le troisième paramètre "DO ON OVERFLOW":
       </P>
	<P>1- Un résulat non saturé.</P>
	<P>2- Un résultat saturé.</P>
	<P>3- Un message d'erreur est signalé lorsqu'un dépassement intervient.</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUM_f' type='LATEX'>
Le bloc somme réalise l'addition de ses entrées.
Ce bloc peut additionner des scalaires ou des vecteurs d'entrée.
</FILE>

<FILE name='SUPER_f' type='LATEX'>
This block opens up a new Scicos window for editing a new block
diagram. This diagram describes the internal functions of the super
block.  

Super block inputs and outputs (regular or event) are
designated by special (input or output) blocks.  

Regular input blocks
must be numbered from 1 to the number of regular input ports. Regular
input ports of the super block are numbered from the top of the block
shape to the bottom.  Regular output portss must be numbered from 1 to
the number of regular output ports. Regular output ports of the super
block are numbered from the top of the block shape to the bottom.
Event input blocks must be numbered from 1 to the number of event
input ports. Event input ports of the super block are numbered from
the left of the block shape to the right.  Event output ports must be
numbered from 1 to the number of event output ports. Event output
ports of the super block are numbered from the left of the block shape
to the right.
</FILE>

<FILE name='SWITCH2' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH2_m' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH_f' type='LATEX'>
Ce bloc est un 'interrupteur' manuel.
Il sélectionne une de ses entrées pour la rédigirer vers sa sortie.
Les entrées non sélectionnées ne sont donc pas propagées.
</FILE>

<FILE name='SampleCLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The difference between the SampleCLK and the CLOCK_c is that
        all the SampleCLK blocks in our diagram are synchronous. The
        synchronism is done due to two differents methods of computation
        in the compilation phase.
        </P>
	<P>
        The first method consists of computing a clock that is faster
        than all the SampleCLK connected to a counter which activate
        the event select block.
        </P>
	<P>The clock is calculated due to the following rule.</P>
	<P>
        If all the blocks have the same offset then the frequency of
        the clock is the gcd of the sample time, and the offset of the
        clock is equal to the offset.
        </P>
	<P>
        If the offsets are differents, then the frequency of the clock
        is the gcd of the sample time and the offset, and the offset of
        the clock is equal to 0.
        </P>
	<P>
        The Counter counts from one to the least commun multiple of the
        sample time (lcm).
        </P>
	<P>
        The number of outputs of the ESELECT_f block is equal to the lcm.
        </P>
	<P>
        The second method uses the Multifrequency block it generates
        events only for specific time. Events in this method are not
        periodicly generated as in the first one.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Sigbuilder' type='LATEX'>
The Signal Builder block is a superblock containing a
\htmladdnormallink{CURVE\_c}{CURVE_c.htm} block whose output event
port is connected to its input event port. This event feedback gives
the possibility to generate events at discontinuous point of the
signal. The generated events automatically restart the numerical
solver and avoids numerical problems. The generated event is also made
available to the user for possible use. Remind that if higher
interpolation methods are used, the events are generated only at the
beginning and at the end of the signal.
</FILE>

<FILE name='SineVoltage' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un bloc Modelica pour une source de tension sinusoïdale.
La résistance ohmique interne de ce bloc est zéro.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Sinks_pal' type='LATEX'>
Dans la palette Sinks, vous pouvez trouver une variété de
blocs utilisés pour afficher (Scope) et écrire les données
dans des fichiers pendant la simulation ainsi que des ports
de sortie utilisés dans les superblocs.\\
Les blocs de cette palette ne possèdent pas de ports réguliers
de sortie.
</FILE>

<FILE name='SourceP' type='LATEX'>
Ce composant représente une source thermohydraulique de pression
constante. Ce bloc est défini avec sa pression et sa température.  La
direction positive conventionnelle est quand le fluide sort du bloc.
</FILE>

<FILE name='Sources_pal' type='LATEX'>
La plupart des blocs de la palette source peuvent être compris comme
des générateurs de données.
Cette palette contient aussi des blocs pour lire des données dans des
fichers, ainsi que des ports d'entrée utilisés dans les superblocs.\\
Les blocs de cette palette ne possèdent pas de ports réguliers d'entrée.
</FILE>

<FILE name='Switch' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
This is a non-ideal two-pole switch. If the explicit input become
positive, two pins are connected via a resistor of resistance
RON). Otherwise, two pins are connected via ROFF resistance.  Note
that using this block may result in a stiff model, so try to choose
proper error tolerances.

    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='TANBLK_f' type='LATEX'>
$$y={\rm tan}(u)$$
</FILE>

<FILE name='TCLSS' type='LATEX'>
Ce bloc réalise un système d'équations d'etat en temporel continu avec
la possibilités de réaliser des sauts dans l'état.
Le nombre d'entrées de ce bloc est deux.
La première entrée est l'entrée régulière du système linéaire.
La seconde fournie la valeur du nouvel état qui est copié dans l'état du système lorsque le bloc est activé par un événement sur son unique port d'entrée événementiel.
Cela signifique que l'état du système saute à la valeur présente sur le deuxième port d'entrée (de taille égale à l'état du système).
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Les tailles des entrées et des sorties sont ajustées automatiquement.
</FILE>

<FILE name='TCLSS_f' type='LATEX'>
Ce bloc réalise un système d'équations d'etat en temporel continu avec
la possibilités de réaliser des sauts dans l'état.
Le nombre d'entrées de ce bloc est deux.
La première entrée est l'entrée régulière du système linéaire.
La seconde fournie la valeur du nouvel état qui est copié dans l'état du système lorsque le bloc est activé par un événement sur son unique port d'entrée événementiel.
Cela signifique que l'état du système saute à la valeur présente sur le deuxième port d'entrée (de taille égale à l'état du système).
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Les tailles des entrées et des sorties sont ajustées automatiquement.
</FILE>

<FILE name='TEXT_f' type='LATEX'>
Ce bloc spécial est utilisé pour ajouter du texte dans un diagramme scicos.
Il n'affecte pas la simulation.
</FILE>

<FILE name='TIME_DELAY' type='LATEX'>
Ce bloc retarde l'entrée par un laps de temps spécifié.
Il peut être utilisé pour la simulation d'un retad temporel.
Au début de la simulation, le bloc délivre la valeur du paramètre
{\bf Initial input} jusqu'à ce que le temps de la simulation dépasse
le paramètre {\bf Time delay}, auquel cas, le bloc commence à réaliser
le retard.\\
La valeur du paramètre {\bf Time delay} doit être non-négative.
</FILE>

<FILE name='TIME_f' type='LATEX'>
Ce bloc est un générateur de temps.\\
La seule sortie régulière de ce bloc donne le temps courant de la
simulation.
</FILE>

<FILE name='TKSCALE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='TOWS_c' type='LATEX'>
Ce bloc est utilisé pour transférer des données simulées dans
l'environnement Scilab.\\
A chaque instants d'échantillonnage, aussi bien les dates que les valeurs
de l'entrée sont enregistrées.
</FILE>

<FILE name='TRASH_f' type='XML'>
<DESCRIPTION>
 <DESCRIPTION_INDENT> 
  <DESCRIPTION_ITEM>
  <P>
  Ce bloc est un bloc de terminaison.
  Il ne fait rien.
  </P>
  </DESCRIPTION_ITEM>
 </DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ThermoHydraulics_pal' type='LATEX'>
La boîte à outils de thermohydraulique contient certains composants
thermohydrauliques tels que la source de pression, le tuyau, les vannes
réglantes, etc.
</FILE>

<FILE name='Threshold_pal' type='LATEX'>
Les blocs de cette palette sont utilisés pour détecter des passages à
certaines valeurs des variables d'état pendant la simulation.
Ces blocs utilisent les solveurs (EDO ou EAD) pour réaliser cette
opération.
</FILE>

<FILE name='TrigFun' type='LATEX'>
The Trigonometric Function block performs numerous common
trigonometric functions. You can select one of these functions from
the Function list: sin, cos, tan, asin, acos, atan, atan2, sinh, cosh,
and tanh. The block output is the result of the operation of the
function on the input or inputs. 
</FILE>

<FILE name='VARIABLE_DELAY' type='LATEX'>
The Variable Transport Delay block can be used to simulate a variable
time delay. The block might be used to model a system with a pipe
where the speed of a motor pumping fluid in the pipe is variable. The
block accepts two inputs: the first input is the signal that passes
through the block; the second input is the time delay. 
</FILE>

<FILE name='VVsourceAC' type='LATEX'>
Ce bloc est un modèle pour une source de tension CA contrôlable. Ce
composant fournit une tension sinusoidale entre ses
ports. L'amplitude de la tension de sortie est définie par une entrée
explicite et la fréquence est définie par l'utilisateur. La résistance
ohmique de ce bloc est zéro.
</FILE>

<FILE name='VanneReglante' type='LATEX'>
Le bloc de VanneReglante représente une Vanne Reglante ou une vanne à
orifice variable. Le débit du fluide passe par la vanne et est
proportionnel à l'ouverture de vanne, {\it c.-à-d.},

\[
  \Delta P \times h\times\left| h \right| = k\times Q\times \left|Q\right|
\]

là où $h$ est l'ouverture de vanne, $\delta P$ est la différence de
pression, et $Q$ est le débit. Ce modèle est seulement employé pour
les régimes laminaires d'écoulement. $k$ est une constante qui dépend
de la géométrie de la vanne et de la masse volumique de fluide.
</FILE>

<FILE name='VariableResistor' type='LATEX'>
Ce composant représente une résistance ohmique variable. La résistance
est commandée par le port d'entrée explicite.  \[ R_x = \frac {V}{I}
\]
</FILE>

<FILE name='VoltageSensor' type='LATEX'>
Ce composant est employé pour mesurer la différence de tension entre
deux noeuds dans un circuit électrique. Le signal de sortie est la
différence entre la tension du port noir et celle du port blanc.
La conductance ohmique de ce bloc est zéro.
</FILE>

<FILE name='VsourceAC' type='LATEX'>
Ce composant est une source de tension CA avec une tension de sortie
sinusoidale. L'amplitude et la fréquence de la tension de sortie
sont définies par l'utilisateur. La résistance ohmique de ce bloc est
zéro.
</FILE>

<FILE name='WFILE' type='LATEX'>
Ce bloc permet à l'utilisateur de sauvegarder des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Chaque appel au bloc correspond à un enregistrement.
Chaque enregistrement à la forme suivante :  $[t,V1,...,Vn]$ où $t$ est la valeur du temps lorsque le bloc est appelé et $V_i$ est la $i^{\rm\grave{e}me}$ valeur d'entrée.
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{RFILE}{RFILE.htm}.
</FILE>

<FILE name='WFILE_f' type='LATEX'>
Ce bloc permet à l'utilisateur de sauvegarder des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Chaque appel au bloc correspond à un enregistrement.
Chaque enregistrement à la forme suivante :  $[t,V1,...,Vn]$ où $t$ est la valeur du temps lorsque le bloc est appelé et $V_i$ est la $i^{\rm\grave{e}me}$ valeur d'entrée.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{RFILE\_f}{RFILE_f.htm}.
</FILE>

<FILE name='WRITEAU_f' type='LATEX'>
Ce bloc écrit un fichier son de type 'au'.
Les données doivent être rangées avec un canal par colonne.
Les valeurs en dehors de l'échelle [-1 +1] seront coupées à l'écriture.
L'écriture 'au' supporte les données multi-canaux pour les formats
'8-bit mu-law' et '8-,16-bit linear'.
</FILE>

<FILE name='WRITEC_f' type='LATEX'>
Ce bloc permet d'écrire des données dans un fichier C au format binaire.
</FILE>

<FILE name='ZCROSS_f' type='LATEX'>
Un événement est généré lorsque toutes les entrées traverse la valeur
zéro simultanément.
</FILE>

<FILE name='buildouttb' type='LATEX'>
Construit une liste "outtb" initialisée.
</FILE>

<FILE name='c_block' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en C.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='create_palette' type='XML'>
  <DESCRIPTION>
     <DESCRIPTION_INDENT>
     <DESCRIPTION_ITEM>
     <P>
      Cette fonction génére une palette si Path est une chaîne de caractères
      indiquant un répertoire où se trouvent des fonctions d'interfaçages de
      blocs scicos.
      Si Path est absent ou bien si celui est égal à %t, les palettes
      standards de Scicos sont construites.
      Si Path est égal à %f, alors seul le paramètre IntFunc est retourné
      (le paramètre routines est vide dans ce cas).
     </P>
     </DESCRIPTION_ITEM>
     </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='curblock' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='fortran_block' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en fortran.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='freq_div' type='LATEX'>
Ce bloc est un superbloc.
L'entrée événementielle est redirigée une fois parmi n à la sortie.
</FILE>

<FILE name='func_block' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='generic_block' type='LATEX'>

</FILE>

<FILE name='generic_block2' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='generic_block3' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='get_scicos_version' type='XML'>
  <DESCRIPTION>
     <DESCRIPTION_INDENT>
     <DESCRIPTION_ITEM>
     <P>
     Cette fonction retourne le numéro de version courant de Scicos.
     </P>
     </DESCRIPTION_ITEM>
     </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='getblocklabel' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='getscicosvars' type='XML'>
  <DESCRIPTION>
    <P>
    Cette fonction utilitaire est utilisée pour retrouver les tableaux de travail du
    compilateur et du simulateur scicos pendant la simulation.
    </P>
    <P>
      Elle peut-être utilisée dans un bloc scilab pour retourner des informations de
      tous types de blocs. Cette fonction est très utile pour débugger les diagrammes
      et pour prototyper des simulations.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='lincos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Construct a linear state-space system by linearizing a model
	  given as a Scicos diagram.
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  The output is a Scilab data structure of type continuous-time state-space
          linear system.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='phase_simulation' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Cette fonction permet de savoir si le simulateur scicos est dans sa phase
          d'intégration temporelle.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='pointer_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Cette fonction retourne un vecteur indiquant le type (algébrique ou différentiel)
    des variables d'états continues utilisées dans un bloc.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos' type='LATEX'>
Scicos est un éditeur graphique pour construire des modèles
de systèmes dynamiques hybrides.\\
L'appel à Scicos sans argument ouvre une fenêtre vierge de l'éditeur.
Les modèles peuvent alors être assemblés, chargés, sauvegardés,
compilés, simulés en utilisant les différentes interfaces utilisateur
graphiques (GUI) de l'éditeur.
Scicos est en fait une interface pour la compilation et le
simulateur 'scicosim'.
Des arguments en entrée et en sortie de la commande scicos peuvent
aussi être utilisées pour réaliser des opérations de débogage.
</FILE>

<FILE name='scicos_block' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_cpr' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_debug' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Cette fonction sert à paramétrer le niveau de débogage de la simulation
          scicos.
	</P>
	<P>
	  Elle peut être utilisée soit en mode "Calc" dans l'éditeur Scicos ou en tant
          qu'instruction dans un bloc scilab et encore dans une fonction d'interfaçage.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_diagram' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_graphics' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_link' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_model' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_params' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_sim' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_simulate' type='XML'>
  <DESCRIPTION>
    <P>
      This function is used to simulate scicos diagrams in batch
      mode. It requires the scs_m structure which can be obtained by
      loading in Scilab the .cos file (e.g. load
      mydiagram.cos).
    </P>
    <P>
      Contrary to the function <LINK> scicosim</LINK>, the diagram
      need not be compiled before being saved.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_state' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_time' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='scicosim' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Simulator for Scicos compiled diagram.
	</P>
	<P>
	  Usually scicosim is called by scicos to perform simulation of
	  a diagram.
	</P>
	<P>
	  But scicosim may also be called outside Scicos. Typical usage
	  in such a case may be :
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<DESCRIPTION_ITEM>
	  <P>
	    1- Use Scicos to define a block diagram, compile it.
	  </P>
	  <P>
	    2- Save the compiled diagram using Save,SaveAs Scicos menus.
	  </P>
	  <P>
	    3- In Scilab, load saved file using load function. You get
	       variables scicos_ver, scs_m, %cpr scs_m is the diagram Scicos
               main data structure.
	  </P>
	  <P>
	    %cpr is the data structure containing (state,sim,cor,corinv)
	    if the diagram had been compiled before saved, else %cpr=list().
	  </P>
	  <P>
	    4- Extract state, sim out of cpr.
	  </P>
	  <P>
	    5- Execute [state,t]=scicosim(state,0,tf,sim,'start',tol) for
               initialisation.
	  </P>
	  <P>
	    6- Execute [state,t]=scicosim(state,0,tf,sim,'run',tol) for
	       simulation from 0 to tf.
	  </P>
	  <P>
	    Many successives such calls may be
	    performed changing initial and final time.
	  </P>
	  <P>
	    7- Execute [state,t]=scicosim(state,0,tf,sim,'finish',tol) at
	       the very end of the simulation to close files,...
	  </P>
	</DESCRIPTION_ITEM>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  For advanced user it is possible to "manually"
	  change some parameters or state values.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scifunc_block' type='LATEX'>
This block can realize any type of Scicos block. The function of the
block is defined interactively using dialogue boxes and in Scilab
language. During simulation, these instructions are interpreted by
Scilab; the simulation of diagrams that include these types of blocks
is slower. For more information see Scicos reference manual. 
</FILE>

<FILE name='scifunc_block_m' type='LATEX'>
This block can realize any type of Scicos block. The function of the
block is defined interactively using dialogue boxes and in Scilab
language. During simulation, these instructions are interpreted by
Scilab; the simulation of diagrams that include these types of blocks
is slower. For more information see Scicos reference manual. 
</FILE>

<FILE name='set_blockerror' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='set_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Cette fonction permet de définir un vecteur indiquant le type (algébrique ou différentiel)
    des variables d'états continues utilisées dans un bloc.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='steadycos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This function finds the steady state for a given system described
	  by a Scicos diagram. The diagram consists in general of a Super
	  block with input and output port blocks. The steady states
	  concerns only the continuous-time dynamics.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='var2vec' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Les fonctions var2vec / vec2var sont utilisées dans les fonctions
          d'interfaçages des blocs scilab pour donner la possibilité à l'utilisateur de
          manipuler des objets scilab avec le registre des paramètres réels (rpar) et
          avec le registre des états discrets (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='vec2var' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Les fonctions var2vec / vec2var sont utilisées dans les fonctions
          d'interfaçages des blocs scilab pour donner la possibilité à l'utilisateur de
          manipuler des objets scilab avec le registre des paramètres réels (rpar) et
          avec le registre des états discrets (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>


</DATA>
