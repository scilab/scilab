<DATA flag="desc">

<FILE name='ABCD_Blocks' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='ABSBLK_f' type='LATEX'>
The Abs block outputs the absolute value of the input.
</FILE>

<FILE name='ABS_VALUE' type='LATEX'>
The Abs block outputs the absolute value of the input.
</FILE>

<FILE name='AFFICH_f' type='LATEX'>
This block displays the value of its unique input inside the block (in
the diagram) during simulation. The block must be located in the main
Scicos window.\\   
{\bf Warning:} each time the block is moved user must click on it to set its
parameters. The display position is then automatically updated.    
</FILE>

<FILE name='AFFICH_m' type='LATEX'>
This block displays the value of its unique input inside the block (in
the diagram) during simulation. The block must be located in the main
Scicos window.\\   
{\bf Warning:} each time the block is moved user must click on it to set its
parameters. The display position is then automatically updated.  
</FILE>

<FILE name='ANDBLK' type='LATEX'>
The Bus Creator block combines a set of signals, i.e., a
group of signals represented by a single line in a block diagram. It
allows you to reduce the number of lines required to route signals
from one part of a diagram to another. This makes your easier to
understand.  
</FILE>

<FILE name='ANDLOG_f' type='LATEX'>
This block, with two event inputs and a regular output, outputs +1 or
-1 on its regular output depending on input events.     
\begin{enumerate}
\item[+1]: When events are synchronously (present on both event input ports),

\item[-1]: When only one event is present.
 \end{enumerate}
</FILE>

<FILE name='BACKLASH' type='LATEX'>
The Backlash block implements a system in which a change in input
causes an equal change in output. However, when the input changes
direction, an initial change in input has no effect on the output.
The amount of side-to-side play in the system is referred to as the
{\em dead-band or gap}.
</FILE>

<FILE name='BIGSOM_f' type='LATEX'>
The Sum block performs addition  on its inputs. This block can add
scalar or vector inputs.
</FILE>

<FILE name='BITCLEAR' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks set the specified bit of the integer input to 0.
	  The user can specify the bit in the field:"index of bit".
	  Bit 0 is the least significant bit.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BITSET' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks set the specified bit of the integer input to 1.
	  The user can specify the bit in the field:"index of bit".
	  Bit 0 is the least significant bit.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BOUNCE' type='LATEX'>

</FILE>

<FILE name='BOUNCEXY' type='LATEX'>

</FILE>

<FILE name='Bache' type='LATEX'>
The {\bf Bache} block represents a thermal-hydraulic tank or reservoir.
This block has two inlets and two outlets whose altitudes can be
changed by the user.  Conventionally, for input ports (black ports)
flow direction is positive when fluid flows into the tank.  On the
other hand, for output ports (white ports) flow direction is positive
when fluid flows out of the tank. The user can set the surface area of
the tank, the initial temperature and initial level of the fluid in
the tank.  If an input or output port is left unused, it should be
blocked by a {\bf stopper} block.
</FILE>

<FILE name='Branching_pal' type='LATEX'>
In the branching palette, you can find miscellaneous blocks
for the management of the data driven by the regular links.
</FILE>

<FILE name='CANIMXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of
          the two regular input signals by drawing the second input
          as a function of the first at instants of events on the
          event input port.  When a point is drawn on screen it stays
          until the buffer length is reached. This scope is useful to
          make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CANIMXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of
          the three regular input signals by drawing the third input
          as a function of the two others at instants of events on the
          event input port. When a point is drawn on screen it stays
          until the buffer length is reached. This scope is useful to
          make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CBLOCK' type='LATEX'>
This block creates skeleton of the C-computing function. It also
creates library file and object files.  
</FILE>

<FILE name='CEVENTSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the input event
          signals.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CFSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This is a floating scope block.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLINDUMMY_f' type='LATEX'>
This block should be placed in any block diagram that contains a
zero-crossing block but no continuous system with state. The reason
for that is that it is the ode solver that find zero crossing
surfaces.  
</FILE>

<FILE name='CLKFROM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect events ports. For more
          information on how it works please refer to the
          documentation of the FROM block by clicking on the link in
          the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKGOTO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect events ports. For more
	  information on how it works please refer to the
	  documentation of the GOTO block by clicking on the link in
	  the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKGotoTagVisibility' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used in the event case. For more information
	  on how it works please refer to the documentation of the
	  GotoTagVisibility block by clicking on the link in
	  the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKINV_f' type='LATEX'>
This block must only be used inside Scicos Super Blocks to represent
an event input port. In a Super Block, the event input ports must be
numbered from 1 to the number of event input ports.
</FILE>

<FILE name='CLKIN_f' type='LATEX'>
This block must only be used inside Scicos Super Blocks to represent
an event input port. In a Super Block, the event input ports must be
numbered from 1 to the number of event input ports.
</FILE>

<FILE name='CLKOUTV_f' type='LATEX'>
This block must only be used inside Scicos Super Blocks to represent 
an event output port. In a Super Block, the event output ports must be
numbered from 1 to the number of event output ports.
</FILE>

<FILE name='CLKOUT_f' type='LATEX'>
This block must only be used inside Scicos Super Blocks to represent
an event output port. In a Super Block, the event output ports must be
numbered from 1 to the number of event output ports.
</FILE>

<FILE name='CLKSOMV_f' type='LATEX'>
This block is an event addition block with up to three inputs. The
output reproduces the events on all the input ports. Strictly
speaking, CLKSOMV is not a Scicos block because it is discarded at the
compilation phase. The inputs and output of CLKSOMV are synchronized.
</FILE>

<FILE name='CLKSOM_f' type='LATEX'>
This block is an event addition block with up to three inputs. The
output reproduces the events on all the input ports. Strictly
speaking, CLKSOM\_f is not a Scicos block because it is discarded at the
compilation phase. The inputs and output of CLKSOM\_f are synchronized.
</FILE>

<FILE name='CLKSPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='CLOCK_c' type='LATEX'>
This block is a Super Block constructed by feeding back the output of
the block  \htmladdnormallink{EVTDLY\_c}{EVTDLY_c.htm} into its input
event port. \\
The unique output of this block generates a regular train of events
that's scheduled by the dialog parameter {\bf Period}.
</FILE>

<FILE name='CLOCK_f' type='LATEX'>
This block is a Super Block constructed by feeding back the output of
an event delay block into its input event port. The unique output of
this block generates a regular train of events.
</FILE>

<FILE name='CLR' type='LATEX'>
This block realizes a SISO linear system represented by its rational
transfer function {\bf Numerator/Denominator}. The rational function must
be proper.
</FILE>

<FILE name='CLR_f' type='LATEX'>
This block realizes a SISO linear system represented by its rational
transfer function  {\bf Numerator/Denominator}. The rational function must
be proper.   
</FILE>

<FILE name='CLSS' type='LATEX'>
This block realizes a continuous-time linear state-space system.
\begin{eqnarray}
\dot x&=&Ax+Bu\\
  y   &=&C*x+D*u
\end{eqnarray}
The system is defined by the $(A,B,C,D)$ matrices and the initial state
$x_0$. The dimensions must be compatible.
</FILE>

<FILE name='CLSS_f' type='LATEX'>
This block realizes a continuous-time linear state-space system.
\begin{eqnarray}
\dot x&=Ax+Bu\\
  y   &=C*x+D*u
\end{eqnarray}
The system is defined by the $(A,B,C,D)$ matrices and the initial state
$x_0$. The dimensions must be compatible.
</FILE>

<FILE name='CMAT3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  CMAT3D is a scope that shows matrix values as z values on a
          xy grid.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CMATVIEW' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  CMATVIEW is a scope that shows matrix values on a colormapped
	  grid.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CMSCOPE' type='LATEX'>
When you start a simulation, Scicos open Scope windows.  The Scope
block displays its input with respect to simulation time. The Scope
block can have multiple axes (one per port); all axes have a common
time range with independent y-axes. The Scope allows you to adjust the
amount of time and the range of input values displayed. 
</FILE>

<FILE name='CONST' type='LATEX'>
This block is a constant value generator.
</FILE>

<FILE name='CONSTRAINT_f' type='LATEX'>
 Defines implicit algebraic relations.
</FILE>

<FILE name='CONST_f' type='LATEX'>
This block is a constant value(s) generator. 
</FILE>

<FILE name='CONST_m' type='LATEX'>
This block is a constant value generator.
</FILE>

<FILE name='CONVERT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block converts an input signal of any data type to a
        specified data type. The input can be real, complex or integer.
        When the output is an integer and when overflow occurs the block
        three different forms of results :
        </P>
	  <P>1- A normal non saturated result.</P>
	  <P>2- A saturated result.</P>
	  <P>3- An error message warning the user about the overflow..</P>
	<P>
        The user can select one of these three forms by setting
        the "DO ON OVERFLOW" field to 0,1 or 2.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='COSBLK_f' type='LATEX'>
$$y=\cos(u)$$
</FILE>

<FILE name='CSCOPE' type='LATEX'>
The Scope block displays its input with respect to simulation
time. Both axes have a common range.  The Scope allows you to adjust
the amount of time and the range of input values displayed.   
</FILE>

<FILE name='CSCOPXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the
          two regular inputs signals by drawing the second input as a
          function of the first at instants of events on the event input
          port. When a point is drawn on screen it stays until the
          simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CSCOPXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the
          three regular inputs signals by drawing the third input as a
          function of the two others at instants of events on the event
          input port. When a point is drawn on screen it stays until the
          simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CUMSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The CUMSUM block sums the element of an input m*n matrix u
          along either the rows, the columns or the first non singleton
          dimension. When the "Sum along" parameter is set to "1", the
          block sums across the elements of each row. The result will be
          displayed as a m*1 matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "2", the block sums
          across the elements of each column. The result will be display
          as a 1*n matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "0", the block sums
          across the first non singleton dimension. The result will be
          displayed as one element.
	  This block is equivalent to cumsum in scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CURVE_c' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>

This block allows the user to create signals and use them as a signal
source block. The signals can be created either graphically by the
user or be defined by specifying two vectors, i.e., a vector for time
and a vector for amplitude. These vectors define the mesh points and
the signal value at intermediate points are obtained by interpolating
the points. Several interpolation methods are available. This block
can also generate the signal periodically. It is also possible to read
data from Excel data-sheets and from formatted C data files.

</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CURV_f' type='LATEX'>
This block defines a tabulated function of time. Between mesh points
block performs a linear interpolation. Outside tabulation block
outputs last tabulated value.  User may define the tabulation of the
function using a curve editor.  
</FILE>

<FILE name='Capacitor' type='LATEX'>
A capacitor is an electrical component that can store energy in
electrical circuits. The relationship between the voltage $V$ across a
capacitor with capacitance $C$ and the current $I$ passing through it
is given by the:
\[
I = C\frac{dV}{dt}     
\]
Capacitors can also be used to differentiate between high-frequency
and low-frequency signals and this makes them useful in electronic
filters. A capacitor has a high impedance when a signal is low frequency
signals.
</FILE>

<FILE name='ConstantVoltage' type='LATEX'>
This component is a model for any device or system that produces a
constant electromotive force between its port. The output voltage of
this DC voltage source is defined by the user. The black port
indicates the positive voltage. The ohmic resistance of this DC
voltage source is zero.
</FILE>

<FILE name='Counter' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block counts from minimal to maximal or from maximal
          to minimal depending on the choice of the rule.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CurrentSensor' type='LATEX'>
This block is inserted in series in an electrical circuit to measure
the current passing through the component. The measure is given to the
explicit part of the model via an explicit pout. Conventionally,
current flowing into the black port is considered positive. The ohmic
resistance of this block is zero.
</FILE>

<FILE name='DEADBAND' type='LATEX'>
Provide a region of zero output
</FILE>

<FILE name='DEBUG_SCICOS' type='LATEX'>

</FILE>

<FILE name='DELAYV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DELAY_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This compiled super-block implements a discretized delay
	  It is build with a shift register and a clock.
          The value of the delay is given by
          the discretization time step multiplied by the
          number-1 of state of the register.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DEMUX' type='LATEX'>
Given a vector valued input this block splits inputs over vector
valued outputs. So $ u=[y_1;y_2,\cdots;y_n]$ , where  $y_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.    
</FILE>

<FILE name='DEMUX_f' type='LATEX'>
Given a vector valued input this block splits inputs over vector
valued outputs. So $ u=[y_1;y_2,\cdots;y_n]$ , where  $y_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.
</FILE>

<FILE name='DERIV' type='LATEX'>
The Derivative block approximates the derivative of its input
by computing:
$$\frac{\Delta u}{\Delta t}$$ 
</FILE>

<FILE name='DFLIPFLOP' type='LATEX'>
The DFLIPFLOP block outputs the input state when the enable is
set and on the rising edge of the clock. The input is D the
enable is en and the clock is clk. Q and !Q are the outputs of
this block. This block is almostly used with digital number, 
the input data type is int8.\\

The truth table of this block is
\begin{tabular}{|c|c||c|c|}
\hline
en&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
0&
1\\
\hline
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DIFF_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLATCH' type='LATEX'>
This block outputs the input state when the input gate is high.
The input is D the enable is C. Q and !Q are the outputs of 
this block. This block is almost used with digital number, 
the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
C&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline 
0&
1&
0&
1\\
\hline 
1&
0&
0&
1\\
\hline 
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DLR' type='LATEX'>
This block realizes a SISO linear system represented by its rational
transfer function (in the symbolic variable z). The rational function
must be proper.
</FILE>

<FILE name='DLRADAPT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLR_f' type='LATEX'>
This block realizes a SISO linear system represented by its rational
transfer function (in the symbolic variable z). The rational function
must be proper.   
</FILE>

<FILE name='DLSS' type='LATEX'>
This block realizes a discrete-time linear state-space system. The
system is defined by the $(A,B,C,D)$ matrices and the initial state
$x_0$. The dimensions must be compatible. At the arrival of an input
event on the unique input event port, the state is updated.
</FILE>

<FILE name='DLSS_f' type='LATEX'>
This block realizes a discrete-time linear state-space system. The
system is defined by the $(A,B,C,D)$ matrices and the initial state
$x_0$. The dimensions must be compatible. At the arrival of an input
event on the unique input event port, the state is updated.   
</FILE>

<FILE name='DOLLAR' type='LATEX'>
The Unit Delay block delays its input by the specified sample
period. This block is equivalent to the z-1 discrete-time
operator. The block accepts one input and generates one output, which
can be either both scalar or both vector. If the input is a vector,
all elements of the vector are delayed by the same sample period.
</FILE>

<FILE name='DOLLAR_f' type='LATEX'>
The Unit Delay block delays its input by the specified sample
period. This block is equivalent to the z-1 discrete-time
operator. The block accepts one input and generates one output, which
can be either both scalar or both vector. If the input is a vector,
all elements of the vector are delayed by the same sample period. 
</FILE>

<FILE name='DOLLAR_m' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The Unit Delay block delays its input by the specified sample
        period. This block is equivalent to the z-1 discrete-time
        operator. The block accepts one input and generates one output,
        which can be either both scalar or both vector. If the input is a
        vector, all elements of the vector are delayed by the same sample
        period.
        </P>
	<P>
         This block can support all data types supported by Scicos.
         The output will inherit its datatype from the
         "initial condition".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DemoBlocks_pal' type='LATEX'>
The Blocks of that palette are used in some Scicos
diagrams of demonstration.
</FILE>

<FILE name='Diode' type='LATEX'>
This component consists of a simple diode parallel with an ohmic
resistance ($R$). The current passing through this component is
defined as a function of the voltage across the ports, {\it i.e.},

\[ i = I_{ds} ( \exp^{v/V_t}- 1)+\frac{v}{R}\]

where $I_{ds}$ and $V_t$ are the saturation current and the voltage
equivalent of temperature, respectively. If the exponent $v/V_t$
reaches a certain limit ($Maxexp$), the diode characteristic becomes
linear to avoid overflow.
</FILE>

<FILE name='EDGETRIGGER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EDGE_TRIGGER' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='ESELECT_f' type='LATEX'>
Special block similar to If-Then-Else. Input and output are synchronized.
The incoming event is directed to one of the output event ports depending
on the value of the regular input.
</FILE>

<FILE name='EVTDLY_c' type='LATEX'>
One event is generated  {\bf Delay}  after an event enters the unique
input event port. Block may also generate an initial output event.
The event date of that block is computed by the formula :
\begin{eqnarray}
 t_{i}&=&t_{\rm{init}} + i * T_{\rm{delay}},
\end{eqnarray}
where $t_{\rm{init}}$ the date of initial output event, $T_{\rm{delay}}$
the delay and $i$ and internal integer discrete counter.
</FILE>

<FILE name='EVTDLY_f' type='LATEX'>
One event is generated after an event enters the unique
input event port. The delay is defined by the dialogue 
parameter {\bf Delay}.Block may also generate an initial
output event.   
</FILE>

<FILE name='EVTGEN_f' type='LATEX'>
One event is generated on the unique output event port if  Event time
is larger than equal to zero, if not, no event is generated.   
</FILE>

<FILE name='EVTVARDLY' type='LATEX'>
One event is generated Delay after an event enters the unique input
event port.
The value of the delay is read from the regular input port.
Block may also generate an initial output event.  
</FILE>

<FILE name='EXPBLK_f' type='LATEX'>
This block realizes $y(i)=a^u(i)$. The input and output port sizes are
determined by the compiler.   
</FILE>

<FILE name='EXPBLK_m' type='LATEX'>
This block realizes $y(i)=a^u(i)$. The input and output port sizes are
determined by the compiler.
</FILE>

<FILE name='EXPRESSION' type='LATEX'>
The Expression block applies the specified Scilab functions to its input. 
</FILE>

<FILE name='EXTRACT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The EXTRACT block extracts some elements from the matrix.
          The size of the output depends on the number of rows and
          number of columns to extract.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTRACTBITS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block outputs a contiguous selection of bits from the input
        integer number.The Bits to extract defines the method by which
        the user select the output bits.
        </P>
	  <P>
          1- When "Upper Half" is selected the block outputs the half
             of the input that contain the most significant bit. In this
             case the third parameter "number of bits or index of bit"
             is ignored.
          </P>
	  <P>
          2- When "Lower Half" is selected the block outputs the half
             of the input that contain the least significant bit. In this
             case the third parameter "number of bits or index of bit"
             is ignored.
          </P>
	  <P>
          3- When "Range starting with most significant bit" is selected
             the block outputs certain number of bits of the input that
             contain the most significant bit. In this case the third
             parameter "number of bits or index of bit" defines the
             number of bits to extract.
          </P>
	  <P>
          4- When "Range ending with least significant bit" is selected
             the block outputs certain number of bits of the input that
             contain the least significant bit. In this case the third
             parameter "number of bits or index of bit" defines the
             number of bits to extract.
          </P>
	  <P>
          5- When "Range of bits" is selected the block outputs a range
             of bits of the input. In this case the third parameter
             "number of bits or index of bit" defines the range of bits
             to extract, it must be a vector with the format [start,end].
          </P>
	<P>
        The extracted value depends on the forth parameter "Treat bit
        field as an integer". When it is set to 0 the input scaling is
        used to determine the output scaling. When it is set to 1, only
        the extracted bits forms the output number.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTRACTOR' type='LATEX'>
Extracts or select a regular input from a multiple regular input.
</FILE>

<FILE name='EXTTRI' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The EXTTRI block extracts some elements from the input matrix u.
        </P>
	<P>
        When the "Extraction type" is set to "1", the block copies the
        elements on and above the main diagonal to an output matrix of
        the same size. The elements below the main diagonal are set to
        zero.
        </P>
	<P>
        When the "Extraction type" is set to "2", the block copies the
        elements on and below the main diagonal to an output matrix of
        the same size. The elements above the main diagonal are set to
        zero.
        </P>
	<P>
        When the "Extraction type" is set to "3", the block copies the
        elements on the main diagonal to an output matrix of the same
        size. The elements above and below the main diagonal are set to
        zero.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Electrical_pal' type='LATEX'>
Electrical toolbox contains very basic electrical components
such as voltage source, diode, capacitor, etc.
</FILE>

<FILE name='Events_pal' type='LATEX'>
The events palette is used to handle events in the diagram.
It contains several activation clocks, synchronous blocks and
blocks to gather events in a single link.
</FILE>

<FILE name='Extract_Activation' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='FROM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The main role of the GOTO/FROM blocks is to transport signals
        from a block to another block without connecting them physically.
        The FROM block transports its received data (from the
        corresponding GOTO) to its output. Multiples FROM blocks can
        receive data from one GOTO, although a GOTO can send data to
        multiple FROM.
        </P>
	<P>
        The GOTO and FROM blocks are connected by the tag parameter.
        </P>
	<P>
        For information on the visibility and limitation of these blocks
        please refer to the GOTO documentation.
        </P>
	<P>
        This block can support all the data types.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect Modelica blocks. For more
          information on how it works please refer to the documentation
          of the FROM block by clicking on the link in the "See also"
          field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMWSB' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Add here a paragraph of the function description
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMWS_c' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Add here a paragraph of the function description
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FSV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GAINBLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The GAINBLK computes the product of a square matrix A by the
          input matrix U, where the number of rows/cols of A is equal to
          the number of rows of U. The input/output datatype is defined
          by the type of the Gain matrix A. It can take all the datatype.
	  On overflow, the result can take different forms:
        </P>
	<P>1- A normal non saturated result.</P>
	<P>2- A saturated result.</P>
	<P>3- An error message warning the user about the overflow.</P>
	<P>
          The user can select one of these three forms by setting the
          "DO ON OVERFLOW" field to 0,1 or 2.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GAINBLK_f' type='LATEX'>
The GAINBLK computes the product of a square matrix A by 
the input matrix U, where the number of rows/cols of A is 
equal to the number of rows of U.
</FILE>

<FILE name='GAIN_f' type='LATEX'>
That block computes the product of a square matrix A by
the input matrix U, where the number of rows/cols of A is
equal to the number of rows of U.
</FILE>

<FILE name='GENERAL_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GENSIN_f' type='LATEX'>
This block is a sine wave generator: $M*\sin(F*t+P) $ 
</FILE>

<FILE name='GENSQR_f' type='LATEX'>
This block is a square wave generator: output takes values  -M  and  M
. Every time an event is received on the input event port, the output
switches from  -M  to  M , or  M  to  -M .    
</FILE>

<FILE name='GOTO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The main role of the GOTO/FROM blocks is to transport signals
        from a block to another block without connecting them physically.
        The GOTO block transports its input data to its corresponding
        FROM block. A simple GOTO block can send data to multiple FROM,
        although a FROM can receive data from only one GOTO.
        </P>
	<P>
        The GOTO and FROM blocks are connected by the tag parameter.
        </P>
	<P>
        The "Tag Visibility" parameter indicates if the location of
        the FROM block is limited:
        </P>
	  <P>
          - Local: means that the corresponding FROM of that GOTO must
                   be in the same subsystem.
          </P>
	  <P>
          - Scoped: means that the corresponding FROM of that GOTO must
                    be in the same subsystem or in any subsystem below
                    the GotoTagVisibility block in the model hierarchy.
          </P>
	  <P>
          - Global: means that the corresponding FROM of that GOTO can
                    be anywhere in the model.
          </P>
	<P>
        This block can support all the data types.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GOTOMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect Modelica blocks. For more
          information on how it works please refer to the documentation
          of the GOTO block by clicking on the link in the "See also"
          field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibility' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block defines the accessibility of the GOTO block
          when it is configure as "scoped". The FROM block corresponding
          to that GOTO must be in the same subsystem of the
          GotoTagVisibility or in subsystems below it in the model
          hierarchy.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibilityMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used in case of Modelica connection.
          For more information on how it works please refer to the
          GotoTagVisibility block by clicking on the link in the
          "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Ground' type='LATEX'>
The Ground element is a single port component providing a reference
voltage in electrical circuits. The potential at the ground node is
zero. Every electrical circuit has to contain at least one ground
element.
</FILE>

<FILE name='HALT_f' type='LATEX'>
This block has a unique input event port. Upon the arrival of an
event, the simulation is stopped and the main Scicos window is
activated. Simulation can be restarted or continued (Run button).   
</FILE>

<FILE name='HYSTHERESIS' type='LATEX'>
Switch output between two constants.The Relay block allows its output
to switch between two specified values. When the relay is on, it
remains on until the input drops below the value of the Switch off
point parameter. When the relay is off, it remains off until the input
exceeds the value of the Switch on point parameter. The block accepts
one input and generates one output. 
</FILE>

<FILE name='IFTHEL_f' type='LATEX'>
One event is generated on one of the output event ports when an input
event arrives. Depending on the sign of the regular input, the event
is generated on the first or second output.  
This is a Synchro block, {\em i.e.}, input and output event are synchronized. 
</FILE>

<FILE name='IMPSPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='INIMPL_f' type='LATEX'>
Inport blocks are the links from outside a system into the system.
</FILE>

<FILE name='INTEGRAL' type='LATEX'>
This block is an integrator. The output is the integral of the input.   
</FILE>

<FILE name='INTEGRAL_f' type='LATEX'>
This block is an integrator. The output is the integral of the input.
</FILE>

<FILE name='INTEGRAL_m' type='LATEX'>
This block is an integrator. The output is the integral of the input.
</FILE>

<FILE name='INTMUL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The INTMUL block computes the matrix multiplication of two
        integers inputs matrices.The number of rows of the second
        matrix must be equal to the number of columns of the first
        matrix. The output is a matrix where the number of rows is
        equal to the number of rows of the first input matrix and
        the number of columns is equal to the number of columns of
        the second input matrix. This block support all the integer
        data type.
        </P>
	<P>
        On overflow, the result can take different forms:
        </P>
	 <P>1- A normal non saturated result.</P>
	 <P>2- A saturated result.</P>
	 <P>3- An error message warning the user about the overflow.</P>
	<P>
        The user can select one of these three forms by setting
        the "DO ON OVERFLOW" field to 0,1 or 2.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='INTRP2BLK_f' type='LATEX'>
The output of this block is a function of the inputs obtained by
bilinear interpolation. This block has two scalar inputs and a single
scalar output. The $X(i)$ and $Y(i)$ give respectively the $X$ coordinate
and the $Y$ coordinate of the $i$-th data point to be interpolated and
$Z(Y(i),X(i))$ its value.   
</FILE>

<FILE name='INTRPLBLK_f' type='LATEX'>
The output of this block is a function of the input obtained by linear
interpolation. This block has a single scalar input and a single scalar
output port. The $X$ coord. and $Y$ coord. give respectively the $X$
coordinate and the $Y$ coordinate of the data points to be interpolated.
 $X$ coord must be strictly increasing.   
</FILE>

<FILE name='INVBLK' type='LATEX'>
This block computes $y(i)=1/u(i)$.
The input (output) size is determined by the context.
</FILE>

<FILE name='INVBLK_f' type='LATEX'>
This block computes  $y(i)=1/u(i)$. The input (output) size is
determined by the context  
</FILE>

<FILE name='IN_f' type='LATEX'>
This block must only be used inside Scicos Super Blocks to represent a
regular input port. The input size is determined by the context.  In a
Super Block, regular input ports must be numbered from 1 to the number
of regular input ports.
</FILE>

<FILE name='ISELECT_f' type='LATEX'>
Select signals from an incoming events. This block has one regular
input port.    
</FILE>

<FILE name='ISELECT_m' type='LATEX'>
Select signals from an incoming events. This block has one regular
input port. 
</FILE>

<FILE name='Inductor' type='LATEX'>
 Inductor is an electrical component that can store energy in
electrical circuits.  The relationship between the voltage $v$ across
the ports of an inductor of inductance $L$ and the current $I$ passing
through it is given by:

\[v = L \frac{dI}{dt}\]

Inductors can also be used to differentiate between high-frequency and
low-frequency signals and this makes them useful in electronic
filters. An inductor shows a high impedance for high frequency
signals.
</FILE>

<FILE name='Integer_pal' type='LATEX'>
That palette is dedicated to handle integer numbers.
Various basic operators for the management of bit fields and
for logic are implemented as well as common gates encountered
in digital circuits.
</FILE>

<FILE name='JKFLIPFLOP' type='LATEX'>
The JK flip flop is the most versatile of the basic flip-flops.
It has two inputs traditionally labeled J and K. When J and K are
different, the output takes the value of J at the next falling edge.
When J and K are both low, no change occurs in the output state,
when they are both high the output will toggle from one state to other.
It can perform the functions of the set/reset flip-flop and has the
advantage that there are no ambiguous states. It can also act as a
T flip-flop to accomplish toggling action if J and K are tied together.
This toggle application finds extensive use in binary counters. 
This block is almost used with digital number, the input data type
is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
J&
K&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
!Q(t-1)&
Q(t-1)\\
\hline
\end{tabular}
</FILE>

<FILE name='Keyboard_shortcuts' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='LOGBLK_f' type='LATEX'>
This block realizes  $y(i)=log(u(i))/log(a)$ . The input and output port
sizes are determined by the context.  
</FILE>

<FILE name='LOGIC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block implements a standard truth table for modeling
          programming array, digital circuit and any other boolean
          expressions. The user can specify a matrix that defines all
          the possible block output in the Truth table field. Each row
          of the matrix contains the output of different combination
          of input elements. The number of rows must be a power of two,
          it defines the number of inputs using the equation:
        </P>
	<P>number of row = 2 ^ (number of input)</P>
	<P>
          The number of outputs is equal to the number of columns of
          the matrix.
        </P>
	<P>
          This block support only the int8 data type. When the input
          is positive, the input is considered as logical 1, When it is
          negative or zero it is considered as logical 0.
        </P>
	<P>
          This block can be activated by an implicit input event or it
          can inherit the clock from the regular input.
        </P>
	<P>
          This block is used to implement SR and JK flip-flops.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='LOGICAL_OP' type='LATEX'>
The Logical Operator block performs the specified logical operation on
its inputs. An input value is TRUE (1) if it is nonzero and FALSE (0)
if it is zero. 
</FILE>

<FILE name='LOOKUP_f' type='LATEX'>
This block realizes a non-linear function defined using a graphical
editor.    
</FILE>

<FILE name='Linear_pal' type='LATEX'>
That palette contains basic linear operators and sub-systems.
</FILE>

<FILE name='MATBKSL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATBKSL block outputs the left matrix division. It is
          a solution to A*x=B. The higher input is the A matrix, the
          lower one is the B matrix, and the output is x. If A is an
          M-by-N1 matrix, B must be a M-by-N2 where N1 and N2 can be
          different or equal.
	  The output x is a N1-by-N2 matrix.
        </P>
	<P>
          The equivalent of BACKSLASH is "\" in Scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATCATH' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATCATH Block outputs the horizontal concatenation
          of multiple matrices. It is also called concatenation
          according to the columns. The inputs U1,U2,...,Un must
          have the same number of rows. The output is a
          M-by-(N1+N2+...+Nn) matrix, where N1,N2,...,Nn are the
          numbers of columns of the inputs matrices, and M is the
          number of rows.
	</P>
	<P>
          The equivalent of MATCATH in Scilab is y=[U1 U2 ... Un].
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATCATV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATCATV Block outputs the vertical concatenation of
          multiple matrices. It is also called concatenation according
          to the rows. The inputs U1,U2,...,Un must have the same
          number of columns. The output is a (M1+M2+...+Mn)-by-N
          matrix, where M1,M2,...,Mn are the numbers of rows of the
          inputs matrices, and N is the number of columns.
	</P>
	<P>
          The equivalent of MATCATH in Scilab is y=[U1;U2;...;Un]
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDET' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATDET outputs the determinant of a square input matrix.
        If the input A=[A11 A12 A13;A21 A22 A23;A31 A32 A33] then the
        output of the block has the form of:
        y=A11*(A22*A33-A23*A32)-A12*(A21*A33-A23*A31)+A13*(A21*A32-A22*A31).
       </P>
	<P>
        The equivalent of MATDET in Scilab is "det"
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDIAG' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATDIAG block create a diagonal matrix from a 1D vector.
          If the input is a M-by-1 vector than the output is an M-by-M
          matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDIV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        The MATDIV block outputs the right matrix division. It is a
        solution to x*B=A. The higher input is the A matrix, the lower
        one is the B matrix, and the output is x. If A is an M1-by-N
        matrix, B must be a M2-by-N where M1 and M2 can be different
        or equal. The output x is a M1-by-M2 matrix.
        </P>
	<P>
        The equivalent of BACKSLASH is "/" in Scilab.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATEIG' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATEIG calculate the eigenvalues and the eigenvectors
        of a square input matrix U.
        </P>
	<P>
        When the "Decomposition type" is set to 1, the block outputs
        the eigenvalues in a vector form, if the input is a M-by-M
        matrix the output is a M-by-1 vector.
        </P>
	<P>
        When the "Decomposition type" is set to 2, the block outputs
        two matrices. for an M-by-M input matrix,the first output is
        a M-by-M diagonal matrix composed by the eigenvalues, and the
        second is a M-by-M matrices composed by the eigenvectors; the
        eigenvectors are represented by the columns of the matrix.
        </P>
	<P>
        The equivalent of the MATEIG block in Scilab is "spec(A)"
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATEXPM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATEXPM outputs the matrix exponential of a square
          matrix input by the pade's approximants. The output is
          a square matrix with the same size of the input. The
          equivalent of this block in Scilab is "expm".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATINV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATINV Block outputs the inverse of a square input matrix
          using the LU factorization. A warning message is printed if
          the input is badly scaled or nearly singular. The equivalent
          function of this block in Scilab is "inv".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATLU' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATLU Block outputs two matrices L and U, with row
          pivoting, from the LU factorization of a square input
          matrix. If A is the input matrix then E*A=L*U where E
          is the permutation matrix.The equivalent function of
          this block in Scilab is "[l,u,e]=lu(A)"
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATMAGPHI' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>MATMAGPHI Block has two types of decomposotions.</P>
	<P>
        When the type is set to one, the block converts a complex
        number to the magnitude and the radian angle, in this case
        the input is complex and the outputs are real double. If
        the input is real double, the angle will be zero or PI and
        the magnitude will be equal to the absolute of the input number.
        </P>
	<P>
        When the type is set to two, the block outputs a complex number
        given the magnitude and the radian angle. In this case the inputs
        are real double and the output is complex.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATMUL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATMUL block computes the matrix multiplication of two
          inputs matrices.The number of rows of the second matrix must
          be equal to the number of columns of the first matrix. The
          output is a matrix where the number of rows is equal to that
          of the first input matrix and the number of columns is equal
          to that of the second input matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATPINV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATPINV Block outputs the inverse of a non square input
        matrix using the SVD theory.if the SVD decomposition of A is
        equal to:
        </P>
	 <P>A=USV'</P>
	<P>
        The pseudoinverse x of A is given by:
        </P>
	 <P>X=VS"U' where S"(i,j)=1/S(i,j) (if S(i,j)~=0),
	    U' and V are respectively the transpose of U and V'.
         </P>
	<P>
        and we have A*X*A=A and X*A*X=X. Both A*X and X*A
        are Hermitian . A warning message is printed if the input
        is badly scaled or nearly singular.
        </P>
	<P>
        When the input is a M-by-N matrix the output is a
        N-by-M matrix. The equivalent function of this block
        in Scilab is "pinv".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATRESH' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The RESHAPE block changes the dimensions of a matrix or
          a vector to another dimensions specified by the user in
          the "output size desired" label. The output size must be
          less or equal to the input size.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATSING' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        The MATSING block computes the economy sized SVD of the
        M-by-N input matrix A by finding U,S and V such that
        </P>
	 <P>A=U*S*V'.</P>
	<P>
        When the decomposition type is set to one, the output is
        a vector composed by the singular values.
        </P>
	<P>
        When the decomposition type is set to two, we have three
        outputs: the second output is a diagonal matrix S composed
        by the singular values and the other two outputs are the
        unitary matrices U and V.
        </P>
	<P>
        The equivalent function of this block in Scilab is "svd".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATSUM block returns the sum of the element of an input
          matrix/vector. When the Sum along is set to all the block
          outputs the sum of all the elements of the matrix. The
          output is then a scalar. When the Sum along is set to lines
          the block is a row-wise sum. The output is a row vector.
	  When the Sum along is set to Columns the block is a column-wise
          sum. The output is a column vector.
	  The equivalent function of this block in Scilab is: "sum".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATTRAN' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This Block transposes an MxN matrix to a NxM matrix. For
          complex data type it uses the hermitian transpose. The
          equivalent of this block in Scilab is y=u'.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZCONJ' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks computes the conjugate of a complex input matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZREIM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block decomposes a complex number by separating the real
          and imaginary parts or compose a complex number by joining the
          two parts. The user can select even to separate or to join real
          and imaginary part by setting the decomposition type to 1 or 2.
          When it is set to 1, the input is a complex matrix and the
          outputs are the real and imaginary parts of the input. When it
          set to 2, The inputs are two real matrices, the output is a
          complex number with real part the first input and imaginary
          part the second input.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MAXMIN' type='LATEX'>
The MinMax block outputs either the minimum or the maximum element or
elements of the inputs. You can choose the function to apply by
selecting one of the choices from the Function parameter list.  
</FILE>

<FILE name='MAX_f' type='LATEX'>
That block find the max value in the elements of its input vector.
</FILE>

<FILE name='MBLOCK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    The block "MBlock" provides an easy way to build a Scicos block
    whose behavior is specified by a Modelica program.  Using this
    block, the user will be able to write and compile Modelica
    programs in Scicos without creating any interfacing function.  The
    associated Modelica program of this block can be either given in a
    file or written in the window opened by the block. In order to
    link this block to other Scicos blocks that may be other Modelica
    blocks, the types of block ports' as well as their associated variables
    should be specified.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MCLOCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MEMORY_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MFCLCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MIN_f' type='LATEX'>
That block find the min value in the elements of its input vector.
</FILE>

<FILE name='MOTOR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MUX' type='LATEX'>
Given  $n$  vector valued inputs this block merges inputs in an single
output vector. So  $y=[u_1;u_2;\cdots;u_n]$ , where  $u_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.    
</FILE>

<FILE name='MUX_f' type='LATEX'>
Given  $n$  vector valued inputs this block merges inputs in an single
output vector. So  $y=[u_1;u_2;\cdots;u_n]$ , where  $u_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.
</FILE>

<FILE name='M_SWITCH' type='LATEX'>
The Multi-Port Switch block chooses between a number of inputs. The
first (top) input is called the control input, while the rest of the
inputs are called data inputs. The value of the control input
determines which data input is passed through to the output port. 
</FILE>

<FILE name='M_freq' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This blocks generates events at specific sample time of the
        simulation time. The sample time is given in the "Sample Time"
        field and the offset is given in the "Offset" field. This
        block has one event input, the number of event outputs depends
        on the number of different sample time. For example if the vector
        of sample time is [1 1 2] and the vector of offset is [0 .5 0]
        then the block has 7 outputs.
        </P>
	<P> - The first output is activated when the simulation time
              is equal to a multiple of the first sample time plus
              the first offset
        </P>
	<P> - The second output is activated when the simulation time
              is equal to a multiple of the second sample time plus
              the second offset.
        </P>
	<P> - The third output is activated when we have both cases,
              first case and second case.
        </P>
	<P> - The fourth output is activated when the simulation time
              is equal to a multiple of the third sample time plus
              the third offset.
        </P>
	<P> - The fifth output is activated when we have both cases,
              first case and forth case.
        </P>
	<P> - The sixth output is activated when we have both cases,
              second case and fourth case.
        </P>
	<P> - The seventh output is activated when we have both cases,
              third case and forth case.
        </P>
	<P> etc...</P>
	<P>
        So the number of outputs is equal to 2**number of different
        time values. Each of these time values is represented by a
        binary number associated to the output's number in decimal.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Matrix_pal' type='LATEX'>
Matrix palette contains all blocks that you need to
do simple and complex matrix operations.
</FILE>

<FILE name='Menu_entries' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='Modulo_Count' type='LATEX'>
It is a discrete block. The block outputs a periodic scalar signal
having a waveform that the user specifies.     
</FILE>

<FILE name='NEGTOPOS_f' type='LATEX'>
An output event is generated when the unique input crosses zero with a
positive slope.   
</FILE>

<FILE name='NPN' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This model is a simple model of a bipolar NPN junction transistor according to Ebers-Moll.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='NRMSOM_f' type='LATEX'>
The Merge block combines its inputs into a single output line whose
value at any time is equal to the most recently computed output of its
driving blocks. You can specify any number of inputs by setting the
block's Number of inputs parameter.  
</FILE>

<FILE name='Non_linear_pal' type='LATEX'>
That palette contains nonlinear functions.
</FILE>

<FILE name='OUTIMPL_f' type='LATEX'>
Outport blocks are the links from a system to a destination outside
the system.
</FILE>

<FILE name='OUT_f' type='LATEX'>
This block must only be used inside Scicos Super Blocks to represent a
regular output port. In a Super Block, regular output ports must be
numbered from 1 to the number of regular output ports.  Size of the
output is determined by the compiler according to the connected blocks
port sizes.
</FILE>

<FILE name='OldBlocks_pal' type='LATEX'>
That palette contains old Scicos blocks.
It is provided to support compatibility with old diagrams
that use old blocks.
</FILE>

<FILE name='Others_pal' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='PDE' type='LATEX'>
This block is an implementation of several numerical schemes (Finite Elements (1st and 2nd order),
Finite Differences (1st and 2nd order), Finite Volumes (1st order)) to solve mono dimensional 
PDE (Partial Differential Equation) within SCICOS.
The mathematical framwork was restricts in PDEs linear scalars with maximum order 2 in time and space.
The goal is to provide engineers and physicists with an easy to use toolbox in SCICOS that will let them
graphically describe the PDE to be solved. A decision system selects the most efficient numerical scheme
depending on the type of the PDE and runs the solvers.
</FILE>

<FILE name='PID' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Add here a paragraph of the function description
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='PNP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This model is a simple model of a bipolar PNP junction transistor
according to Ebers-Moll.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='POSTONEG_f' type='LATEX'>
An output event is generated when the unique input crosses zero with a
negative slope.  
</FILE>

<FILE name='POWBLK_f' type='LATEX'>
This block realizes  $y(i)=u(i)^a$. The input and output port sizes
are determined by the compiler according to the connected blocks port
sizes.   
</FILE>

<FILE name='PRODUCT' type='LATEX'>
The Product block performs multiplication or division of its
inputs. This block produces outputs using either element-wise or
matrix multiplication, depending on the value of the Multiplication
parameter. You specify the operations with the Number of inputs
parameter. Multiply(+1) and divide (-1) characters indicate the
operations to be performed on the inputs.
</FILE>

<FILE name='PROD_f' type='LATEX'>
The output is the element wise product of the inputs.   
</FILE>

<FILE name='PerteDP' type='LATEX'>
A {\bf PertDP} block represents a hydraulic pipe with linear
resistance losses. This component represents a hydraulic resistance
and pressure loss is directly proportional to the flow rate.
Conventionally, the flow direction is the positive when fluid flows
from the black port to the white port.  The pressure loss is obtained
with {\[P_{loss}=P_{black}-P_{white}\].  The key parameters of this
block are the pipes' length, the pipe's diameter, inlet and outlet
altitudes, and some other thermal-hydraulic coefficients.
</FILE>

<FILE name='PotentialSensor' type='LATEX'>
This block is used to measure the voltage with respect to the
reference voltage ({\bf Ground} block) in an electrical circuit. The
voltage is given to the explicit part of the model via an explicit
output port.
</FILE>

<FILE name='PuitsP' type='LATEX'>
This thermal-hydraulic component represents a thermal-hydraulic
constant pressure drain (well). This block is specified with
its pressure and temperature.  Conventionally, the flow
direction is positive when fluid flows into the block.
</FILE>

<FILE name='QUANT_f' type='LATEX'>
This block outputs the quantization of the input according to a choice
of methods:
\begin{enumerate}
\item Round  method:
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)-0.5) &\texttt{if} \; u(i)<0 .\\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)+0.5) &\texttt{if} \; u(i)>=0 .
 \end{eqnarray}
\item Truncation method:
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)) &\texttt{if} \; u(i)<0 .  \\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)) &\texttt{if} \; u(i)>=0 .
\end{eqnarray}
\item Floor method:
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5))  .
\end{eqnarray}
\item  Ceil method:
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5))
\end{eqnarray}
\end{enumerate}
</FILE>

<FILE name='RAMP' type='LATEX'>
The Ramp block generates a signal that starts at a specified time and
value and changes by a specified rate. The block's {\bf Slope , Start
  time} and {\bf Initial output} parameters determine the
characteristics of the output signal. All must have the consistent
dimensions after scalar expansion.    
</FILE>

<FILE name='RAND_f' type='LATEX'>
This block is a random wave generator: each output component takes
piecewise constant random values. Every time an event is received on
the input event port, the outputs take new independent random
values. \\
Output port size is given by the size of  {\bf A}  and  {\bf
 B} vectors.
</FILE>

<FILE name='RAND_m' type='LATEX'>
This block is a random wave generator: each output component takes
piecewise constant random values. Every time an event is received on
the input event port, the outputs take new independent random
values. \\
Output port size is given by the size of {\bf A} and {\bf
 B} matrices.
</FILE>

<FILE name='RATELIMITER' type='LATEX'>
The Rate Limiter block limits the first derivative of the signal
passing through it. The output changes no faster than the specified
limit.  
</FILE>

<FILE name='READAU_f' type='LATEX'>
 Loads a sound file specified by the string *.au file, returning the
 sampled data in y. The .au extension is appended if no extension is
 given. Amplitude values are in the range [-1,+1]. auread supports
 multichannel data in the following formats: 
\begin{itemize}
    \item 8-bit mu-law 
    \item 8-, 16-, and 32-bit linear
    \item Floating-point
\end{itemize}
</FILE>

<FILE name='READC_f' type='LATEX'>
This block allows user to read data in a C file. {\bf Output record
selection} and {\bf Time record Selection} allows the user to select data
among file records. Each call to the block advance one record in the
file.    
</FILE>

<FILE name='REGISTER' type='LATEX'>
This block realizes a shift register. At every input event, the
register is shifted one step.
</FILE>

<FILE name='REGISTER_f' type='LATEX'>
This block realizes a shift register. At every input event, the
register is shifted one step.    
</FILE>

<FILE name='RELATIONALOP' type='LATEX'>
It performs logical comparison of its two inputs. 
</FILE>

<FILE name='RELAY_f' type='LATEX'>
This block routes one of the regular inputs to the unique regular
output. the choice of which input is to be routed is done, initially
by the "initial connected input" parameter. Then, every time an input
event arrives on the i-th input event port, the i-th regular input
port is routed to the regular output.   
</FILE>

<FILE name='RFILE' type='LATEX'>
This block allows user to read data in a file, in formatted or binary
mode. {\bf Output record selection} and {\bf Time record selection} 
allows the user to select data among file records. Each call to the
 block advance one record in the file.\\
The pair block is \htmladdnormallink{WFILE}{WFILE.htm}.
</FILE>

<FILE name='RFILE_f' type='LATEX'>
This block allows user to read data in a file, in formatted or binary
mode. {\bf Output record selection} and {\bf Time record selection}
allows the user to select data among file records. Each call to the
block advance one record in the file.\\
The pair block is \htmladdnormallink{WFILE\_f}{WFILE_f.htm}.
</FILE>

<FILE name='RICC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block computes the solution of Riccati equation using
        different method and for both case continuous and discrete.
        </P>
	<P> The Riccati equation in continuous time is:</P>
	<P>     A*X+X*A+C-X*D*X=0 </P>
	<P> The Riccati equation in discrete time is:</P>
	<P>     A*X*(inv(In-D))*A-X+C=0</P>
	<P>
         where A is an NxN matrix, it is the first input of the block,
         C and D are two NxN symetrics matrices and are respectively the
         second and third input of the RICC block. X represent the
         output of the block, it is also a NxN matrix.
        </P>
	<P>
         The user can choose between two methods of computation. For the
         continuous time he can use even the Schur method or the matrix
         sign function approach method, by setting the Model parameter
         to 1 or 2. For the discrete time, the models are the Schur
         method and the inverse free spectral decomposition method.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='ROOTCOEF' type='LATEX'>
This block computes the coefficients of a polynomial given its root
values.
</FILE>

<FILE name='Resistor' type='LATEX'>
A resistor is a two-port electrical component that resists an electric
current by producing a voltage drop ($V$) between its terminals
according to the Ohm's law.

\[ R = \frac {V}{I}\]

The electrical resistance ($R$) is equal to the voltage drop across
the resistor divided by the current through the resistor ($I$).

</FILE>

<FILE name='SAMPHOLD' type='LATEX'>
Each time an input event is received block copy its input on the
output and hold it until input event. For periodic Sample and hold,
event input must be generated by a {\bf Clock}.
</FILE>

<FILE name='SAMPHOLD_m' type='LATEX'>
Each time an input event is received block copy its input on the
output and hold it until input event. For periodic Sample and hold,
event input must be generated by a {\bf Clock}.
</FILE>

<FILE name='SAMPLEHOLD_f' type='LATEX'>
Each time an input event is received block copy its input on the
output and hold it until input event. For periodic Sample and hold,
event input must be generated by a {\bf Clock}.
</FILE>

<FILE name='SATURATION' type='LATEX'>
The Saturation block imposes upper and lower bounds on a signal. When
the input signal is within the range specified by the Lower limit and
Upper limit parameters, the input signal passes through
unchanged. When the input signal is outside these bounds, the signal
is clipped to the upper or lower bound. When the Lower limit and Upper
limit parameters are set to the same value, the block outputs that
value. 
</FILE>

<FILE name='SAT_f' type='LATEX'>
The Saturation block imposes upper and lower bounds on a signal. When
the input signal is within the range specified by the Lower limit and
Upper limit parameters, the input signal passes through
unchanged. When the input signal is outside these bounds, the signal
is clipped to the upper or lower bound. When the Lower limit and Upper
limit parameters are set to the same value, the block outputs that
value.
</FILE>

<FILE name='SAWTOOTH_f' type='LATEX'>
This block is a sawtooth wave generator: output is $(t-t_i)$ from
$t_i$ to $t_{i+1}$ where $t_i$ and $t_{i+1}$ denote the times of two
successive input events.    
</FILE>

<FILE name='SCALAR2VECTOR' type='LATEX'>
This block  convert a scalar value into a vector of identical
elements.When using blocks with more than one input port (such as the
Sum or Relational Operator block), you can mix vector and scalar
inputs. When you do this, the scalar inputs are expanded into vectors
of identical elements whose widths are equal to the width of the
vector inputs. If more than one input port is a vector, they must
have the same number of elements.
</FILE>

<FILE name='SELECT_f' type='LATEX'>
This block routes one of the regular inputs to the unique regular
output. The choice of which input is to be routed is done, initially
by the {\bf initial connected input} parameter. Then, every time the block
is activated through its i-th input activation port, the i-th regular
input value port is put to the regular output.   
</FILE>

<FILE name='SELECT_m' type='LATEX'>
A Selector block accepts either vector or matrix signals as input. Set
the Input Type parameter to the type of signal (vector or matrix) that
the block should accept in your model. The parameter dialog box and
the block's appearance change to reflect the type of input that you
select. The way the block determines the elements to select differs
slightly, depending on the type of input.
%This block routes one of the regular inputs to the unique regular
%output. The choice of which input is to be routed is done, initially
%by the {\bf initial connected input} parameter. Then, every time the block
%is activated through its i-th input activation port, the i-th regular
%input value port is put to the regular output.
</FILE>

<FILE name='SHIFT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block shifts the bits of the input signal. In this
          operation the digits are moved to the right or to the left.
	  The user can choose the rule to shifts the bits. It can be
          normal or cycle by setting the "Shifttype" parameter to "0"
          or "1".
        </P>
	<P>
          When the Shifttype is 0, an arithmetic shift is applied to the
          input signal. In this case, the bits that are shifted out of
          either end are discarded. Zeros are shifted in on the right,
          in the case of left shift; in the case of right shifts, copies
          of the sign bit is shifted in on the left.
        </P>
	<P>
          When the "Shifttype" is 1,a circular shift is applied to the
          input signal. In this case, the bits are rotated as if the left
          and right ends of the register are joined. The value that is
          shifted in on the right during a left-shift is whatever values
          was shifted out on the left, and vice versa.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SIGNUM' type='LATEX'>
The Sign block indicates the sign of the input: 
\begin{itemize}
\item The output is 1 when the input is greater than zero.
\item The output is 0 when the input is equal to zero.
\item The output is -1 when the input is less than zero.   
\end{itemize}
</FILE>

<FILE name='SINBLK_f' type='LATEX'>
$$y={\rm sin}(u)$$
</FILE>

<FILE name='SLIDER_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='SQRT' type='LATEX'>
This block computes the square root of each element of the
input matrix. It supported real and complex data types.
</FILE>

<FILE name='SRFLIPFLOP' type='LATEX'>
This block describe the simplest and the most fundamental latch
the SR flip flop. Where S and R are the input and Q and !Q are the
outputs.If S (Set) is pulsed high while R is held low, then the Q
output is forced high, and stays high when S returns low; similarly,
if R (Reset) is pulsed high while S is held low, then the Q output
is forced low, and stays low when R returns low. When both are low,
Q(t) takes the same state as Q(t-1). When they are both high, both Q
and !Q take the low values we are in an unstable state. Practically we
have to avoid this case.This block is almost used with digital
number, the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
S&
R&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
0&
0\\
\hline --> This case is to avoid
\end{tabular}
</FILE>

<FILE name='STEP' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='STEP_FUNCTION' type='LATEX'>
The Step block provides a step between two definable levels at a
specified time. If the simulation time is less than the Step time
parameter value, the block's output is the Initial value parameter
value. For simulation time greater than or equal to the Step time, the
output is the Final value parameter value. 
</FILE>

<FILE name='SUBMAT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block outputs a sub matrix of the input matrix.
          The output matrix will be defining by using the parameters
          of this block.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUMMATION' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The Sum block performs addition or subtraction on its inputs.
        This block can add or subtract scalar, vector, or matrix inputs.
        It can also collapse the elements of a single input vector.
        </P>
	<P>
        The number of inputs is given by the second parameter. This
        parameter can be a vector of +1 and -1 or it can be a positive
        value. In the first case the size of the vector indicates the
        number of inputs and the signs indicates whether it is a
        summation or a subtraction. In the second case, the block is
        a summation block and the value indicates the number of inputs.
        </P>
	<P>On overflow, the result can take different forms:</P>
	<P>1- A normal non saturated result.</P>
	<P>2- A saturated result.</P>
	<P>3- An error message warning the user about the overflow.</P>
	<P>
        The user can select one of these three forms by setting the
        "DO ON OVERFLOW" field to 0,1 or 2.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUM_f' type='LATEX'>
The Sum block performs addition  on its inputs. This block can add
scalar, vector, or matrix inputs.   
</FILE>

<FILE name='SUPER_f' type='LATEX'>
This block opens up a new Scicos window for editing a new block
diagram. This diagram describes the internal functions of the super
block.  

Super block inputs and outputs (regular or event) are
designated by special (input or output) blocks.  

Regular input blocks
must be numbered from 1 to the number of regular input ports. Regular
input ports of the super block are numbered from the top of the block
shape to the bottom.  Regular output ports must be numbered from 1 to
the number of regular output ports. Regular output ports of the super
block are numbered from the top of the block shape to the bottom.
Event input blocks must be numbered from 1 to the number of event
input ports. Event input ports of the super block are numbered from
the left of the block shape to the right.  Event output ports must be
numbered from 1 to the number of event output ports. Event output
ports of the super block are numbered from the left of the block shape
to the right.
</FILE>

<FILE name='SWITCH2' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH2_m' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH_f' type='LATEX'>
This is a Manual Switch block. It selects one of its inputs to pass
through to the output. The selected input is propagated to the output,
while the unselected inputs are discarded.  
</FILE>

<FILE name='SampleCLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The difference between the SampleCLK and the CLOCK_c is that
        all the SampleCLK blocks in our diagram are synchronous. The
        synchronism is done due to two different methods of computation
        in the compilation phase.
        </P>
	<P>
        The first method consists of computing a clock that is faster
        than all the SampleCLK connected to a counter which activate
        the event select block.
        </P>
	<P>The clock is calculated due to the following rule.</P>
	<P>
        If all the blocks have the same offset then the frequency of
        the clock is the gcd of the sample time, and the offset of the
        clock is equal to the offset.
        </P>
	<P>
        If the offsets are different, then the frequency of the clock
        is the gcd of the sample time and the offset, and the offset of
        the clock is equal to 0.
        </P>
	<P>
        The Counter counts from one to the least common multiple of the
        sample time (lcm).
        </P>
	<P>
        The number of outputs of the ESELECT_f block is equal to the lcm.
        </P>
	<P>
        The second method uses the Multifrequency block it generates
        events only for specific time. Events in this method are not
        periodically generated as in the first one.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Sigbuilder' type='LATEX'>
The Signal Builder block is a superblock containing a
\htmladdnormallink{CURVE\_c}{CURVE_c.htm} block whose output event
port is connected to its input event port. This event feedback gives
the possibility to generate events at discontinuous point of the
signal. The generated events automatically restart the numerical
solver and avoids numerical problems. The generated event is also made
available to the user for possible use. Remind that if higher
interpolation methods are used, the events are generated only at the
beginning and at the end of the signal.
</FILE>

<FILE name='SineVoltage' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This Modelica block a general sine voltage source. The internal ohmic
resistance is zero.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Sinks_pal' type='LATEX'>
In Sinks palette, you can find a variety of blocks used
to display (Scope) and write data during simulation and also
some output ports used in superblocks.\\
The blocks of that palette doesn't have regular output ports.
</FILE>

<FILE name='SourceP' type='LATEX'>
This thermal-hydraulic component represents a thermal-hydraulic constant
pressure supply. This block is specified with its output pressure and
temperature.  Conventionally, the flow direction is positive when the
fluid flows out of the block.
</FILE>

<FILE name='Sources_pal' type='LATEX'>
Most of blocks of the Source palette can be viewed as data generators.
That palette also contains blocks to read data from files and input
ports used in superblocks.\\
The blocks of that palette doesn't have regular input ports.
</FILE>

<FILE name='TANBLK_f' type='LATEX'>
$$y={\rm tan}(u)$$
</FILE>

<FILE name='TCLSS' type='LATEX'>
This block realizes a continuous-time linear state-space system with
the possibility of jumps in the state. The number of inputs to this
block is two. The first input is the regular input of the linear
system, the second carries the new value of the state which is copied
into the state when an event arrives at the unique event input port of
this block. That means the state of the system jumps to the value
present on the second input (of size equal to that of the state). The
system is defined by the $(A,B,C,D)$ matrices and the initial state
$x_0$. The dimensions must be compatible. The sizes of inputs and outputs
are adjusted automatically.
</FILE>

<FILE name='TCLSS_f' type='LATEX'>
This block realizes a continuous-time linear state-space system with
the possibility of jumps in the state. The number of inputs to this
block is two. The first input is the regular input of the linear
system, the second carries the new value of the state which is copied
into the state when an event arrives at the unique event input port of
this block. That means the state of the system jumps to the value
present on the second input (of size equal to that of the state). The
system is defined by the $(A,B,C,D)$ matrices and the initial state
$x_0$. The dimensions must be compatible. The sizes of inputs and outputs
are adjusted automatically.   
</FILE>

<FILE name='TEXT_f' type='LATEX'>
This special block is only use to add text at any point of the diagram
window. It has no effect on the simulation.   
</FILE>

<FILE name='TIME_DELAY' type='LATEX'>
The Transport Delay block delays the input by a specified amount of
time. It can be used to simulate a time delay. At the start of the
simulation, the block outputs the Initial input parameter until the
simulation time exceeds the Time delay parameter, when the block
begins generating the delayed input. \\
The Time delay parameter must be non-negative. 
</FILE>

<FILE name='TIME_f' type='LATEX'>
This block is a time generator.\\
The unique regular output is the current time.   
</FILE>

<FILE name='TOWS_c' type='LATEX'>
That block is used to put simulated data in the scilab
workspace.\\
Each sampling time, both dates and values of input are recorded.
</FILE>

<FILE name='TRASH_f' type='XML'>
<DESCRIPTION>
 <DESCRIPTION_INDENT>
  <DESCRIPTION_ITEM>
  <P>
   That block is an end-block.
   It do nothing.
  </P>
  </DESCRIPTION_ITEM>
 </DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ThermoHydraulics_pal' type='LATEX'>
Thermal-Hydraulics toolbox contains some basic thermal-hydraulic
components such as pressure source, pipe, control valves, etc.
</FILE>

<FILE name='Threshold_pal' type='LATEX'>
Threshold blocks are used to detect values crossing of state variables
during the simulation.
This blocks use the solvers (ODE or DAE) to do that operation.
</FILE>

<FILE name='TrigFun' type='LATEX'>
The Trigonometric Function block performs numerous common
trigonometric functions. You can select one of these functions from
the Function list: sin, cos, tan, asin, acos, atan, atan2, sinh, cosh,
and tanh. The block output is the result of the operation of the
function on the input or inputs. 
</FILE>

<FILE name='VARIABLE_DELAY' type='LATEX'>
The Variable Transport Delay block can be used to simulate a variable
time delay. The block might be used to model a system with a pipe
where the speed of a motor pumping fluid in the pipe is variable. The
block accepts two inputs: the first input is the signal that passes
through the block; the second input is the time delay. 
</FILE>

<FILE name='VVsourceAC' type='LATEX'>
The variable voltage source block is a model for a controlled AC
voltage source. This component provides a sinusoid voltage across its
ports. The amplitude of the output voltage is governed by the explicit
input and the frequency is defined by the user. The ohmic resistance
of the block is zero.
</FILE>

<FILE name='VanneReglante' type='LATEX'>
The {\bf VanneReglante} block represents a variable orifice control
valve. The flow rate through the valve is proportional to the valve
opening, {\it i.e.},

\[
  \Delta P \times h\times\left| h \right| = k\times Q\times \left|Q\right|
\]

where $h$ is the valve opening, $\Delta P$ is the pressure difference,
and $Q$ is the flow rate. This model is only used for the laminar flow
regimes. $k$ is a constant depending on the valve geometry and
mass density of fluid.
</FILE>

<FILE name='VariableResistor' type='LATEX'>
 This component represents a variable ohmic resistor. The resistance
 ($R_x$) is controlled via an explicit input port.

\[
 R_x = \frac {V}{I}
\]
</FILE>

<FILE name='VoltageSensor' type='LATEX'>
This component is used to measure the voltage difference between two
nodes in an electrical circuit. The output signal is the difference
between the voltages of the black port and the white port, {\it i.e.},

\[V_{output}=V_{black}-V_{white}\]

The ohmic conductance of this block is zero.
</FILE>

<FILE name='VsourceAC' type='LATEX'>
This component is an AC voltage source with sinusoid output
voltage. The amplitude and the frequency of the output voltage is set
by the user. The ohmic resistance of this block is zero.
</FILE>

<FILE name='WFILE' type='LATEX'>
This block allows user to save data in a file, in formatted and binary
mode. Each call to the block corresponds to a record in the file. Each
record has the following form:  $[t,V1,...,Vn]$  where  $t$  is the value
of time when block is called and $ V_i$  is the ith input value.\\
The pair block is \htmladdnormallink{RFILE}{RFILE.htm}.
</FILE>

<FILE name='WFILE_f' type='LATEX'>
This block allows user to save data in a file, in formatted and binary
mode. Each call to the block corresponds to a record in the file. Each
record has the following form:  $[t,V1,...,Vn]$  where  $t$  is the value
of time when block is called and $ V_i$  is the ith input value. \\
The pair block is \htmladdnormallink{RFILE\_f}{RFILE_f.htm}.  
</FILE>

<FILE name='WRITEAU_f' type='LATEX'>
This block  writes a sound file specified by the string *.au file. The
data should  be arranged with one channel per column. Amplitude
values outside the   range [-1,+1] are clipped prior to
writing. auwrite supports  multichannel data for 8-bit mu-law and 8-
and 16-bit linear formats.  
</FILE>

<FILE name='WRITEC_f' type='LATEX'>
This block allows user to write data in a C binary file.  
</FILE>

<FILE name='ZCROSS_f' type='LATEX'>
An output event is generated when all inputs (if more than one) cross
zero simultaneously.    
</FILE>

<FILE name='buildouttb' type='LATEX'>
Build an initialized outtb list.
</FILE>

<FILE name='c_block' type='LATEX'>
This block creates skeleton of the C computing function. Also it
creates library file and object files.  
</FILE>

<FILE name='curblock' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='fortran_block' type='LATEX'>
This block creates skeleton of the FORTRAN computing function. Also it
creates library file and object files.  
</FILE>

<FILE name='freq_div' type='LATEX'>
 This block is a Super Block. The input event is directed once every n
 times to output. The input is  driven by an event clock.
</FILE>

<FILE name='func_block' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='generic_block' type='LATEX'>

</FILE>

<FILE name='generic_block2' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a Scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='generic_block3' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a Scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='getblocklabel' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='getscicosvars' type='XML'>
  <DESCRIPTION>
    <P>
     That utility function is used to retrieve working arrays
     of Scicos simulator and compiler during simulation.
    </P>
    <P>
     It can be used inside a Scilab block to get information of
     all type of blocks. That function is very useful to debug
     diagrams and to do prototypes of simulations.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='lincos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Construct a linear state-space system by linearizing a model
	  given as a Scicos diagram.
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  The output is a Scilab data structure of type continuous-time
          state-space linear system.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='phase_simulation' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  That function says if the Scicos simulator is realizing
          the time domain integration.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='pointer_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Add here a paragraph of the function description
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Scicos is a visual editor for constructing models of hybrid
	  dynamical systems. Invoking Scicos with no argument opens up an
	  empty Scicos window. Models can then be assembled, loaded,
	  saved, compiled, simulated, using GUI of Scicos.  Scicos
	  serves as an interface to the various block diagram compilers
	  and the hybrid simulator scicosim.
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  The input and output arguments are useful for debugging
          purposes.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_block' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_cpr' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_debug' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This Scilab function is used to set the debug level
          of a Scicos simulation.
	</P>
	<P>
	  One can used it in the "Calc" mode of the Scicos editor
          or as an instruction in a Scilab block or in an
          interfacing function.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_diagram' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_graphics' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_link' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_model' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_params' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_sim' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_simulate' type='XML'>
  <DESCRIPTION>
    <P>
      This function is used to simulate Scicos diagrams in batch
      mode. It requires the scs_m structure which can be obtained by
      loading in Scilab the .cos file (e.g. load
      mydiagram.cos).
    </P>
    <P>
      Contrary to the function <LINK> scicosim</LINK>, the diagram
      need not be compiled before being saved.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_state' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_time' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='scicosim' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Simulator for Scicos compiled diagram.
	</P>
	<P>
	  Usually scicosim is called by Scicos to perform simulation of
	  a diagram.
	</P>
	<P>
	  But scicosim may also be called outside Scicos. Typical usage
	  in such a case may be :
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<DESCRIPTION_ITEM>
	  <P>
	    1- Use Scicos to define a block diagram, compile it.
	  </P>
	  <P>
	    2- Save the compiled diagram using Save,SaveAs Scicos menus.
	  </P>
	  <P>
	    3- In Scilab, load saved file using load function. You get
	       variables scicos_ver, scs_m, %cpr scs_m is the diagram
               Scicos main data structure.
	  </P>
	  <P>
	    %cpr is the data structure containing (state,sim,cor,corinv)
	    if the diagram had been compiled before saved,
            else %cpr=list().
	  </P>
	  <P>
	    4- Extract state, sim out of cpr.
	  </P>
	  <P>
	    5- Execute [state,t]=scicosim(state,0,tf,sim,'start',tol)
               for initialisation.
	  </P>
	  <P>
	    6- Execute [state,t]=scicosim(state,0,tf,sim,'run',tol) for
	       simulation from 0 to tf.
	  </P>
	  <P>
	    Many successive such calls may be
	    performed changing initial and final time.
	  </P>
	  <P>
	    7- Execute [state,t]=scicosim(state,0,tf,sim,'finish',tol) at
	       the very end of the simulation to close files,...
	  </P>
	</DESCRIPTION_ITEM>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  For advanced user it is possible to "manually"
	  change some parameters or state values.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scifunc_block' type='LATEX'>
This block can realize any type of Scicos block. The function of the
block is defined interactively using dialogue boxes and in Scilab
language. During simulation, these instructions are interpreted by
Scilab; the simulation of diagrams that include these types of blocks
is slower. For more information see Scicos reference manual.   
</FILE>

<FILE name='scifunc_block_m' type='LATEX'>
This block can realize any type of Scicos block. The function of the
block is defined interactively using dialogue boxes and in Scilab
language. During simulation, these instructions are interpreted by
Scilab; the simulation of diagrams that include these types of blocks
is slower. For more information see Scicos reference manual.
</FILE>

<FILE name='set_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Add here a paragraph of the function description
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='steadycos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This function finds the steady state for a given system
          described by a Scicos diagram. The diagram consists in
          general of a Super block with input and output port blocks.
          The steady states concerns only the continuous-time dynamics.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='var2vec' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  var2vec / vec2var functions are used inside the interfacing
          functions of Scilab blocks to give the possibility to the
          user to handle Scilab objects with the real parameter (rpar)
          and with the discrete state register (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='vec2var' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  var2vec / vec2var functions are used inside the interfacing
          functions of Scilab blocks to give the possibility to the
          user to handle Scilab objects with the register of real
          parameters (rpar) and with the discrete states register (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>


</DATA>
